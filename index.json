{
  "library/docs/extensions/extensions_type.html": {
    "href": "library/docs/extensions/extensions_type.html",
    "title": "TypeExtensions | AllOverIt",
    "keywords": "TypeExtensions Property and method metadata can be obtained for a Type using various reflection methods. It can be difficult, however, to easily extract that information when you need to filter down to specific requirements. AllOverIt includes several methods to simplify the process. The following class is used in the examples below: public class PersonBase { protected int Id { get; set; } } public class Person : PersonBase { public string FirstName { get; set; } public string Surname { get; set; } } GetPropertyInfo() public static PropertyInfo GetPropertyInfo(this Type type, string propertyName); public static IEnumerable<PropertyInfo> GetPropertyInfo(this Type type, BindingOptions binding = BindingOptions.Default, bool declaredOnly = false); Getting PropertyInfo for public or protected properties, by name, is as simple as: var firstNameInfo = typeof(Person).GetPropertyInfo(\"FirstName\"); var surnameInfo = typeof(Person).GetPropertyInfo(\"Surname\"); // assuming 'subject' is of type 'Person' var firstName = firstNameInfo.GetValue(subject); var surname = surnameInfo.GetValue(subject); To get the PropertyInfo of select properties, use any of the following: // all public and protected properties var allInfo = typeof(Person).GetPropertyInfo(); // all properties, including internal and private var allInfo = typeof(Person).GetPropertyInfo(BindingOptions.All); // all properties, including internal and private, of the declared class only // (will not return Id) var allInfo = typeof(Person).GetPropertyInfo(BindingOptions.All, true); GetMethodInfo() public static MethodInfo GetMethodInfo(this Type type, string name); public static MethodInfo GetMethodInfo(this Type type, string name, Type[] types); public static IEnumerable<MethodInfo> GetMethodInfo(this Type type, BindingOptions binding = BindingOptions.Default, bool declaredOnly = false); Getting MethodInfo for any static, instance, public, or non-public method can be obtained by name and, where required, by a list of argument types. // get MethodInfo for StringBuilder.Clear() var methodInfo = typeof(StringBuilder).GetMethodInfo(\"Clear\"); // get MethodInfo for the StringBuilder.AppendFormat() overload: // public StringBuilder AppendFormat(string format, params object[] args); var methodInfo = typeof(StringBuilder).GetMethodInfo( \"AppendFormat\", new[] {typeof(string), typeof(object[])}); The same functionality is also available in the ReflectionHelper namespace. Refer to Obtain Method Information for more information."
  },
  "library/docs/extensions.html": {
    "href": "library/docs/extensions.html",
    "title": "Extension Methods | AllOverIt",
    "keywords": "Extension Methods ExpressionExtensions Refer to the section describing Expressions for examples of available extension methods. ComparableExtensions The IComparable interface allows for one object to be custom compared to another. AllOverIt contains the following extension methods: LessThan<TType>() LessThanOrEqual<TType>() GreaterThan<TType>() GreaterThanOrEqual<TType>() EqualTo<TType>() NotEqualTo<TType>() The following example shows how to compare two Person objects based on their Surname and FirstName . public class Person : IComparable<Person> { public string FirstName { get; } public string Surname { get; } public Person(string firstName, string surname) { FirstName = firstName; Surname = surname; } public int CompareTo(Person other) { // compare by surname, then first name, case insensitively var surnameComparison = CompareName(Surname, other.Surname); return surnameComparison != 0 ? surnameComparison : CompareName(FirstName, other.FirstName); } private static int CompareName(string lhs, string rhs) { return string.Compare(lhs, rhs, StringComparison.InvariantCultureIgnoreCase); } } And this is how it can be used within a LINQ query using the extension methods available in AllOverIt . var persons = new[] { new Person(\"Adam\", \"Baker\"), new Person(\"Adam\", \"Murphy\"), new Person(\"Paul\", \"Nielson\"), new Person(\"Jon\", \"Nielson\") }; // custom comparer will consider them in the following order: // Baker, Adam // Murphy, Adam // Nielson, Jon // Nielson, Paul var comparisonPerson = new Person(\"Amy\", \"Myer\"); var actual = persons.Where( item => item.LessThan(comparisonPerson) ).AsReadOnlyList(); actual.Should().BeEquivalentTo( new Person(\"Adam\", \"Baker\"), new Person(\"Adam\", \"Murphy\") ); DictionaryExtensions GetValueOrDefault() public static TValue GetValueOrDefault<TKey, TValue>( this IDictionary<TKey, TValue> dictionary, TKey key, TValue defaultValue = default) This extension method returns the value associated with a key if found, otherwise it returns a (optional) default value. // assuming managers is of type Dictionary<int, Person> // id is an integer identifier to look up var person = managers.GetValueOrDefault(id); If found, the associated Person instance will be returned, otherwise null . // id is an integer identifier to look up // manager is an instance of a Person object var person = managers.GetValueOrDefault(id, manager); If found, the associated Person instance will be returned, otherwise manager will be. The managers dictionary is not mutated if the key is not found. GetOrSet() public static TValue GetOrSet<TKey, TValue>( this IDictionary<TKey, TValue> dictionary, TKey key, Func<TValue> valueCreator) This extension method returns the value associated with a key if found, otherwise it invokes valueCreator to get the value that should be added to the dictionary, and then returned to the caller. // id is an integer identifier to look up // manager is an instance of a Person object var person = managers.GetValueOrDefault(id, () => manager); If found, the associated Person instance will be returned, otherwise manager will be returned after adding it to the dictionary. The managers dictionary is mutated if the key is not found. DoubleExtensions Comparing double values is problematic due to rounding issues. AllOverIt provides extension methods to help compare a double with another, or zero. The built-in tolerance is defined as 1E-7 . Overloads exist that allow you to provide your own tolerance. public static bool IsZero(this double value); public static bool IsZero(this double value, double tolerance); Compares a double value to zero, within a given tolerance. public static bool IsEqualTo(this double lhs, double rhs); public static bool IsEqualTo(this double lhs, double rhs, double tolerance); Compares to double values with each other, within a given tolerance. EnumerableExtensions AsList(), AsReadOnlyList(), AsReadOnlyCollection() public static IList<TType> AsList<TType>( this IEnumerable<TType> items); public static IReadOnlyList<TType> AsReadOnlyList<TType>( this IEnumerable<TType> items); public static IReadOnlyCollection<TType> AsReadOnlyCollection<TType>( this IEnumerable<TType> items); When working with an Enumerable there is a real concern associated with potentially enumerating it more than once. To overcome this, a commonly used approach is to convert the IEnumerable<TType> to a List<TType> by using the ToList() method. If the items being enumerated is already a list, then calling ToList() will create a second list. This can quickly become a memory and performance issue. The AsList() , AsReadOnlyList() , and AsReadOnlyCollection() methods help solve this by determining if a new collection actually needs to be created. In all cases, if the IEnumerable<TType> is already a list or read-only collection then the same reference is returned, otherwise a new collection is created. IsNullOrEmpty() public static bool IsNullOrEmpty(this IEnumerable items); Applicable to collections and strings, this method returns true if the instance is null or empty, otherwise false. Batch The Batch() method provides the ability to partition data into a group of smaller collections. // partitions items into batches of 100 and processes each batch in parallel foreach (var batch in items.Batch(100).AsParallel()) { ProcessBatch(batch); } private void ProcessBatch(IEnumerable<string> items) { foreach (var item in items) { // process an individual item } } ObjectExtensions GetPropertyValue() public static TValue GetPropertyValue<TValue>(this object instance, string propertyName, BindingFlags bindingFlags ); public static TValue GetPropertyValue<TValue>(this object instance, string propertyName, BindingOptions bindingOptions = BindingOptions.Default); Both versions of GetPropertyValue() use reflection to get the value of an object's property by name. The first version uses .NET's BindingFlags and the second version uses BindingOptions found in AllOverIt . public class Request { public string Token { get; set; } } // using BindingFlags var token = request.GetPropertyValue<string>(nameof(Request.Token), BindingFlags.Instance | BindingFlags.Public); // using BindingOptions (the default is BindingOptions.Default) var token = request.GetPropertyValue<string>(nameof(Request.Token)); SetPropertyValue() public static void SetPropertyValue<TValue>(this object instance, string propertyName, TValue value, BindingFlags bindingFlags); public static void SetPropertyValue<TValue>(this object instance, string propertyName, TValue value, BindingOptions bindingOptions = BindingOptions.Default); Both versions of SetPropertyValue() use reflection to set the value of an object's property by name. The first version uses .NET's BindingFlags and the second version uses BindingOptions found in AllOverIt . public class Request { public string Token { get; set; } } // using BindingFlags request.SetPropertyValue<string>(nameof(Request.Token), \"token_value\", BindingFlags.Instance | BindingFlags.Public); // using BindingOptions (the default is BindingOptions.Default) request.GetPropertyValue<string>(nameof(Request.Token), \"token_value\"); ToPropertyDictionary() public static IDictionary<string, object> ToPropertyDictionary(this object instance, bool includeNulls = false, BindingOptions bindingOptions = BindingOptions.Default); Use this method to convert any object to a dictionary of property key names mapped to their value. The default options exclude null properties and includes properties that are: Static or instance scope Abstract, virtual, or non-virtual access Public or protected visibility As<TType>() public static TType As<TType>(this object instance, TType defaultValue = default); This method will attempt to convert an object to another type. The following conversions are attempted (in the order shown): If null , returns defaultValue If TType is the same type as instance , or TType is object , or TType is a class type, but not a string , then The original reference is returned, casted to a TType . If TType is a Boolean and instance is an integral type ( byte , sbyte , short , ushort , int , uint , long , ulong ) then a zero value will be returned as False, and a value of one will be returned as True. All other values will throw an ArgumentOutOfRangeException exception. If instance is an integral value and TType is an Enum then a conversion will be attempted. If the conversion cannot be performed then an ArgumentOutOfRangeException exception will be thrown. If any of the following are true: TType is a Boolean instance is a Boolean TType is a char instance is a char Then an attempt to convert instance to TType will be performed using Convert.ChangeType() . In all other cases, instance will be converted to a string (using string interpolation) and passed to StringExtensions.As<TType>() for conversion. AsNullable<TType> public static TType? AsNullable<TType>(this object instance, TType? defaultValue = null) where TType : struct; This method behaves identical to As<TType>() . CalculateHashCode() There are two overloads, each of which are described below. public static int CalculateHashCode<TType>(this TType instance, IEnumerable<string> includeProperties = null, IEnumerable<string> excludeProperties = null); This overload uses reflection to find all instance properties and calculate a hash code. The main advantage of using reflection is that it will automatically include properties of all access (abstract, virtual, and non-virtual) and visibility (public, protected, and private). Furthermore, this overload satisfies OCP (Open-Closed Principle) because the hash code will automatically adjust the calculations if properties are added or removed. The includeProperties and excludeProperties options exist to provide finer control over which properties are considered for calculating the hash code. When includeProperties is null then all properties are included, otherwise only those specified are considered. When excludeProperties is null then no properties are excluded, otherwise the specified properties are excluded. public static int CalculateHashCode<TType>(this TType instance, params Func<TType, object>[] propertyResolvers); This overload calculates the hash code based on explicitly specified properties, fields, or the return result from a method call. If properties are added to the class then you must remember to later include those for them to be considered during the hash code calculation. PropertyInfoExtensions Properties can be declared as abstract, virtual, or static, as well as public, protected, private, or internal. Extension methods exist for each of these cases: public static bool IsAbstract(this PropertyInfo propertyInfo); public static bool IsVirtual(this PropertyInfo propertyInfo); public static bool IsStatic(this PropertyInfo propertyInfo); public static bool IsPublic(this PropertyInfo propertyInfo); public static bool IsProtected(this PropertyInfo propertyInfo); public static bool IsPrivate(this PropertyInfo propertyInfo); public static bool IsInternal(this PropertyInfo propertyInfo); These extensions prove to be quite useful when used in conjunction with the TypeInfo extensions or the various methods within ReflectionHelper that return PropertyInfo . For example: public class Person { public string FirstName { get; set; } public string Surname { get; set; } public int Age { get; set; } public string FullName => $\"{FirstName} {Surname}\"; } Assume subject in the following snippet is an instance of Person : var properties = new[] { \"FirstName\", \"Surname\", \"Age\", \"FullName\" }; // Using reflection, this will output the value of each property on `subject` foreach (var property in properties) { // GetPropertyInfo() is an extension method in TypeInfoExtensions var info = typeof(Person).GetPropertyInfo(property); var value = info.GetValue(subject); Console.WriteLine($\"{property} = {value}\"); } The same info can be used to check the visibility of a property: var isPublic = info.IsPublic(); // true var isProtected = info.IsProtected(); // false var isPrivate = info.IsPrivate(); // false var isInternal = info.IsInternal(); // false Or accessibility: var isAbstract = info.IsAbstract(); // false var isVirtual = info.IsVirtual(); // false var isStatic = info.IsStatic(); // false StringExtensions As<TType>() and AsNullable<TType>() public static TType As<TType>(this string value, TType defaultValue = default, bool ignoreCase = true); public static TType? AsNullable<TType>(this string value, bool ignoreCase = true) where TType : struct; Similar to methods of the same name in the objectextensions namespace, these methods attempt to convert a string to another type, typically Boolean, Integral, or Enum types. Supported conversions include byte, sbyte, decimal, double, float, int, uint, long, ulong, short, ushort, string, boolean and enum. Char conversions must be performed using the ObjectExtensions.As<TType>() method. No attempt is made to avoid overflow or argument exceptions. Other conversions are possible if a suitable TypeConverter is available. // each will return a Boolean True (a variable would // normally be in the place of the string) var result = \"true\".As<bool>(); var result = \"TRUE\".As<bool>(); var result = \"TrUe\".As<bool>(); var result = \"1\".As<bool>(); // each will return NumberStyles.Integer (a variable would // normally be in the place of the string) var result = \"7\".As<NumberStyles>(); var result = \"integer\".As<NumberStyles>(); var result = \"Integer\".As<NumberStyles>(); var result = \"INTEGER\".As<NumberStyles>(); TypeExtensions Property and method metadata can be obtained for a Type using various reflection methods. It can be difficult, however, to easily extract that information when you need to filter down to specific requirements. AllOverIt includes several methods to simplify the process. The following class is used in the examples below: public class PersonBase { protected int Id { get; set; } } public class Person : PersonBase { public string FirstName { get; set; } public string Surname { get; set; } } GetPropertyInfo() public static PropertyInfo GetPropertyInfo(this Type type, string propertyName); public static IEnumerable<PropertyInfo> GetPropertyInfo(this Type type, BindingOptions binding = BindingOptions.Default, bool declaredOnly = false); Getting PropertyInfo for public or protected properties, by name, is as simple as: var firstNameInfo = typeof(Person).GetPropertyInfo(\"FirstName\"); var surnameInfo = typeof(Person).GetPropertyInfo(\"Surname\"); // assuming 'subject' is of type 'Person' var firstName = firstNameInfo.GetValue(subject); var surname = surnameInfo.GetValue(subject); To get the PropertyInfo of select properties, use any of the following: // all public and protected properties var allInfo = typeof(Person).GetPropertyInfo(); // all properties, including internal and private var allInfo = typeof(Person).GetPropertyInfo(BindingOptions.All); // all properties, including internal and private, of the declared class only // (will not return Id) var allInfo = typeof(Person).GetPropertyInfo(BindingOptions.All, true); GetMethodInfo() public static MethodInfo GetMethodInfo(this Type type, string name); public static MethodInfo GetMethodInfo(this Type type, string name, Type[] types); public static IEnumerable<MethodInfo> GetMethodInfo(this Type type, BindingOptions binding = BindingOptions.Default, bool declaredOnly = false); Getting MethodInfo for any static, instance, public, or non-public method can be obtained by name and, where required, by a list of argument types. // get MethodInfo for StringBuilder.Clear() var methodInfo = typeof(StringBuilder).GetMethodInfo(\"Clear\"); // get MethodInfo for the StringBuilder.AppendFormat() overload: // public StringBuilder AppendFormat(string format, params object[] args); var methodInfo = typeof(StringBuilder).GetMethodInfo( \"AppendFormat\", new[] {typeof(string), typeof(object[])}); The same functionality is also available in the ReflectionHelper namespace. Refer to Obtain Method Information for more information. TypeInfoExtensions public static IEnumerable<PropertyInfo> GetPropertyInfo(this TypeInfo typeInfo, bool declaredOnly = false); public static PropertyInfo GetPropertyInfo(this TypeInfo typeInfo, string propertyName); These methods are identical to those of the same name in the TypeExtensions namespace, except they extend TypeInfo instead of Type . Refer to TypeExtensions for more information."
  },
  "library/docs/reflection.html": {
    "href": "library/docs/reflection.html",
    "title": "Reflection | AllOverIt",
    "keywords": "Reflection Reflection provides the ability to dynamically create instances of a type, get the type of an existing object and invoke its methods or access its properties. AllOverIt simplifies the access to an object's set of properties and methods by using a set of binding options. Binding Options To simplify the explanation of using reflection binding options, consider the following class: public class SomeClass { public int Prop1 { get; set; } private int Prop2 { get; set; } internal int Prop3 { get; set; } internal int Prop4 { get; private set; } public static bool Prop5 { get; set; } } This class contains a number of properaties that exhibit three categories of binding options: Option Description Scope Refers to whether a property or method is static or instance. Accessor Refers to whether a property or method is virtual, non-virtual, or abstract. Visibility Refers to whether a property or method is public, protected, private, or internal. When querying for properties and methods the binding must include at least one option from each of the three categories. Where a category option has not been provided then the following defaults will be applied: Option Default Applied Scope Static or instance Accessor Virtual, non-virtual, or abstract. Visibility Public or protected. There are also a number of options defined that provide often-used combinations: Option Default Applied DefaultScope Static or instance DefaultAccessor Virtual, non-virtual, or abstract. DefaultVisibility Public or protected. AllScope Static or instance AllAccessor Virtual, non-virtual, or abstract. AllVisibility Public, protected, private or internal. All Combines AllScope , AllAccessor , and AllVisibility Obtain Property Information ProperytInfo can be obtained from an object using any of the following: The static ReflectionHelper.GetPropertyInfo() generic methods The GetPropertyInfo() extension method of Type The GetPropertyInfo() extension method of TypeInfo The following example demonstrates how to obtain property metadata based on a class type. public class Person { private string FullName { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public int Age { get; set; } } // obtains all property information using the default binding options var allInfo = ReflectionHelper.GetPropertyInfo<Person>(); // obtains property information for 'FirstName' (uses default binding options) var firstNameInfo = ReflectionHelper.GetPropertyInfo<Person>(\"FirstName\"); // obtains property information for the private property called 'FullName' var fullNameInfo = ReflectionHelper .GetPropertyInfo<Person>(BindingOptions.Private) .Single(item => item.Name == \"FullName\"); The following example demonstrates how to achieve property information from a class instance using the Type extension method: var person = new Person(); var ageInfo = person.GetType().GetPropertyInfo(\"Age\"); Obtain Method Information MethodInfo can be obtained from an object using any of the following: The static ReflectionHelper.GetMethodInfo() generic methods The GetMethodInfo() extension methods of Type The following example demonstrates how to obtain method metadata based on a class type. public class Person { public string FirstName { get; set; } public string LastName { get; set; } public string GetFullName() => $\"{FirstName} {LastName}\"; } // obtains method metadata for 'GetFullName' using default binding options var fullNameInfo = ReflectionHelper .GetMethodInfo<Person>() .Single(item => item.Name == \"GetFullName\"); // when the method takes no arguments the same can be achieved using the following overload: var fullNameInfo = ReflectionHelper.GetMethodInfo<Person>(\"GetFullName\"); For cases where several method overloads exist on a class then the following alternative can be used to find the required MethodInfo by specifying the list of argument types: public static MethodInfo GetMethodInfo<TType>(string name, Type[] types); As an example, StringBuilder has several AppendFormat() methods. To obtain the MethodInfo for this overload: public StringBuilder AppendFormat(string format, params object[] args); Use the following code: var methodInfo = typeof(StringBuilder).GetMethodInfo( \"AppendFormat\", new[] {typeof(string), typeof(object[])}); Convert to a Dictionary<string, object> Property names and their values can be converted to a dictionary as shown in the following example: public class Person { public string FirstName { get; set; } public string MiddleName { get; set; } public string LastName { get; set; } } var person = new Person { FirstName = \"Malcolm\", LastName = \"Smith\" }; // contains FirstName and LastName // excludes null values and uses default binding options var nonNullProperties = person.ToPropertyDictionary(); // contains FirstName, MiddleName and LastName // includes null values and uses default binding options var allProperties = person.ToPropertyDictionary(true);"
  },
  "library/docs/intro.html": {
    "href": "library/docs/intro.html",
    "title": "Introduction | AllOverIt",
    "keywords": "Introduction There's a large number of commonly used routines that get used from one application to the next. AllOverIt is a collection of those routines, backed by an extensive set of unit tests. A goal of AllOverIt is to require nothing more than .NET Standard. There are a handful of classes that have been inspired by the work of others (with credit provided in the source) but everything is ultimately tweaked or enhanced to meet the needs of this library. The entire library is unit tested and aims to continue meeting 100% coverage."
  },
  "library/docs/helpers.html": {
    "href": "library/docs/helpers.html",
    "title": "Helpers | AllOverIt",
    "keywords": "Helpers EnumHelper public static IReadOnlyCollection<TType> GetEnumValues<TType>() where TType : struct, Enum; Provides an easy way to obtain a list of all possible values for a given enum type. For example: // returns Static, Instance, Abstract, Virtual, NonVirtual, Internal, Private, // Protected, Public, DefaultScope, DefaultAccessor, DefaultVisibility, // Default, AllScope, AllAccessor, AllVisibility, All var enumValues = EnumHelper.GetEnumValues<BindingOptions>(); Guard Pre-condition guard checks are a common requirement so AllOverIt provides some useful helpers in this area. Extension methods exist to not only assert that an object is not null (or empty if an IEnumerable<T> ) but they will also return the same value to simplify usage: public static TType WhenNotNull<TType>(this TType argument, string name) where TType : class; public static IEnumerable<TType> WhenNotNullOrEmpty<TType>(this IEnumerable<TType> argument, string name); public static string WhenNotNullOrEmpty(this string argument, string name); Returning the value allows arguments to be assigned to member variables or properties, like so: public class Sample { private readonly string _value; public Sample(string value) { _value = value.WhenNotNullOrEmpty(nameof(value)); } } You can also determine the variable name from an Expression by using the following alternatives: public static TType WhenNotNull<TType>(Expression<Func<TType>> expression) where TType : class; public static IEnumerable<TType> WhenNotNullOrEmpty<TType>( Expression<Func<IEnumerable<TType>>> expression); public static string WhenNotNullOrEmpty(Expression<Func<string>> expression); Usage then becomes: _value = Guard.WhenNotNullOrEmpty(() => value); Use the Expression based versions with caution though as the expression must be compiled and invoked to get the value and variable name. This has a small performance cost associated with it. Raii The Raii and Raii<TType> classes implement the Resource Acquisition Is Initialization idiom. During construction a resource is acquired or initialized and during disposal there is an opportunity to perform custom last-minute cleanup. These classes should ideally be used within a using() block to ensure the disposal is deterministic. While the Raii class is often used for things such as creating and disposing of database connections, it's also useful for automating actions that need to be performed when a unit of work has been completed. The following example represents a logger that sends a message to an Action . The action is a simplified representation of an injected dependency (this implementation is for illustration purposes only). public class Logger { private class ProfilerContext { public Stopwatch Stopwatch { get; } public string Title { get; } public ProfilerContext(string title) { Stopwatch = Stopwatch.StartNew(); Title = title; } } // use the to emulate logging to some external output private readonly Action<string> _action; public Logger(Action<string> action) { _action = action; } public void LogMessage(string message) { _action.Invoke(message);; } public IDisposable GetProfiler(string title) { return new Raii<ProfilerContext>( () => new ProfilerContext(title), context => StopProfiling(context) ); } private void StopProfiling(ProfilerContext context) { var message = $\"{context.Title} took {context.Stopwatch.ElapsedMilliseconds}ms\"; LogMessage(message); } } The Logger contains a GetProfiler() method that returns an IDisposable in the form of a Raii<ProfilerContext> . During construction of this object a Stopwatch is created and immediately starts running. When the IDisposable is diposed of, the cleanup action is executed, resulting in an elapsed log message being processed via the StopProfiling() method. The profiler would be used like so: using (logger.GetProfiler(title)) { // the code to be profiled goes here(false); }"
  },
  "library/docs/expressions.html": {
    "href": "library/docs/expressions.html",
    "title": "Expressions | AllOverIt",
    "keywords": "Expressions PredicateBuilder The following is an example of a lambda expression in the form of a delegate: Func<Product, bool> isPromoted = product => product.Promoted; And the following is the same lambda expression in the form of an expression tree: Expression<Func<Product, bool>> isPromoted = product => product.Promoted; An expression tree can be compiled into the delegate form: Expression<Func<Product, bool>> isPromoted = product => product.Promoted; Func<Product, bool> compiledExpression = isPromoted.Compile(); Expression trees are useful for building composable expressions that can be later compiled into a delegate and used within LINQ queries, amongst other things. Consider the following model with two static methods used for building predicates as an expression tree: private class Product { public int Id { get; } public string Category { get; } public bool Promoted { get; } public Product(int id, string category, bool promoted) { Id = id; Category = category; Promoted = promoted; } public static Expression<Func<Product, bool>> IsPromoted() { return product => product.Promoted; } public static Expression<Func<Product, bool>> IsInCategory(params string[] categories) { var predicate = PredicateBuilder.False<Product>(); foreach (var category in categories) { var temp = category; // must capture for the closure predicate = predicate.Or(p => p.Category.Contains(temp)); } return predicate; } } The IsPromoted() and IsInCategory() methods return an expression that can participate in any IQueryable based query. PredicateBuilder , as shown in IsInCategory() , can be used to dynamically build logical And and Or queries. Let's look at a simple example using the above methods: var products = new List<Product> { new Product(1, \"Fruit\", true), new Product(2, \"Fruit\", false), new Product(3, \"Vegetable\", true), new Product(4, \"Vegetable\", false), new Product(5, \"Vehicle\", true), new Product(6, \"Vehicle\", false) }; var filtered = _products .AsQueryable() .Where(Product.IsPromoted()); This will return items 1, 3 and 5. Let's now compose two queries into one: var isFoodOrVegetable = Product.IsInCategory(\"Fruit\", \"Vegetable\"); var isPromoted = Product.IsPromoted(); var isPromotedFruitOrVegetable = isFoodOrVegetable.And(isPromoted); var filtered = _products .AsQueryable() .Where(isPromotedFruitOrVegetable); The combined query will filter items that are a \"Fruit\" or \"Vegetable\", and is promoted. The combined query will return items 1 and 3. IQueryable based queries are often used for translating LINQ queries into SQL (or similar) based queries by traversing, and translating, the expression tree. For regular, in-memory queries, it is more efficient to create the composite queries and cache them for future use by compiling them: // store in a variable for re-use as required var compiledPredicate = isPromotedFruitOrVegetable.Compile(); var filtered = _products.Where(compiledPredicate); Extensions GetValue() The GetValue() extension method can evaluate ConstantExpression , MemberExpression (property and field members), and MethodCallExpression expressions. Consider the following class and helper method: private class ChildClass { public int Property { get; set; } public int Field; public int GetPropertyValue() { return Property; } } private static int GetValue(Expression<Func<int>> expression) { var value = expression.GetValue(); return value.As<int>(); } Each of the following are possible: // returns 4 (ConstantExpression) var value = GetValue(() => 4); var item = new ChildClass { Property = 10}; // returns 10 (MemberExpression, PropertyInfo) var value = GetValue(() => item.Property); var item = new ChildClass { Field = 20}; // returns 20 (MemberExpression, FieldInfo) var value = GetValue(() => item.Field); var item = new ChildClass { Property = 30}; // returns 30 (MethodCallExpression) var value = GetValue(() => item.GetProperty()); GetMemberExpressions() A MemberExpression may be part of a LambdaExpression , or a UnaryExpression (which may be within a LambdaExpression ). GetMemberExpressions() exists to retrieve all linked MemberExpression s without having to be concerned with unwrapping everything. As an example, consider the following classes: private class ChildClass { public int Property { get; set; } } private class ParentClass { public ChildClass Child { get; set; } } And the following expression: // 'parent' is an instance of 'ParentClass' Expression<Func<int>> expression = () => parent.Child.Property; You can use UnwrapMemberExpression() to get the root MemberExpression from the LambdaExpression and then GetMemberExpressions() to obtain all linked MemberExpression s. // unwrap the LambdaExpression var memberExpression = expression.UnwrapMemberExpression(); var members = memberExpression.GetMemberExpressions() .Select(exp => exp.GetValue()) .AsReadOnlyList(); The calls to GetValue() will result in each expression being evaluated: // members[0] = parent // members[1] = parent.Child // members[2] = parent.Child.Property GetFieldOrProperty() Fields and Properties of an expression are both referenced as MemberExpression s. The GetFieldOrProperty() method returns the appropriate MemberInfo details. The following example shows how to get MemberInfo of a property, but the same applies to fields: Expression<Func<int>> expression = () => parent.Child.Property; var memberInfo = expression.GetFieldOrProperty(); var name = memberInfo.Name; var value = ReflectionHelper.GetMemberValue(memberInfo, parent.Child); name will have the name of the property (\"Property\" in this example) and value will have the current value of the property."
  },
  "library/docs/extensions/extensions_expressions.html": {
    "href": "library/docs/extensions/extensions_expressions.html",
    "title": "ExpressionExtensions | AllOverIt",
    "keywords": "ExpressionExtensions Refer to the section describing Expressions for examples of available extension methods."
  },
  "library/docs/extensions/extensions_enumerable.html": {
    "href": "library/docs/extensions/extensions_enumerable.html",
    "title": "EnumerableExtensions | AllOverIt",
    "keywords": "EnumerableExtensions AsList(), AsReadOnlyList(), AsReadOnlyCollection() public static IList<TType> AsList<TType>( this IEnumerable<TType> items); public static IReadOnlyList<TType> AsReadOnlyList<TType>( this IEnumerable<TType> items); public static IReadOnlyCollection<TType> AsReadOnlyCollection<TType>( this IEnumerable<TType> items); When working with an Enumerable there is a real concern associated with potentially enumerating it more than once. To overcome this, a commonly used approach is to convert the IEnumerable<TType> to a List<TType> by using the ToList() method. If the items being enumerated is already a list, then calling ToList() will create a second list. This can quickly become a memory and performance issue. The AsList() , AsReadOnlyList() , and AsReadOnlyCollection() methods help solve this by determining if a new collection actually needs to be created. In all cases, if the IEnumerable<TType> is already a list or read-only collection then the same reference is returned, otherwise a new collection is created. IsNullOrEmpty() public static bool IsNullOrEmpty(this IEnumerable items); Applicable to collections and strings, this method returns true if the instance is null or empty, otherwise false. Batch The Batch() method provides the ability to partition data into a group of smaller collections. // partitions items into batches of 100 and processes each batch in parallel foreach (var batch in items.Batch(100).AsParallel()) { ProcessBatch(batch); } private void ProcessBatch(IEnumerable<string> items) { foreach (var item in items) { // process an individual item } }"
  },
  "library/docs/extensions/extensions_double.html": {
    "href": "library/docs/extensions/extensions_double.html",
    "title": "DoubleExtensions | AllOverIt",
    "keywords": "DoubleExtensions Comparing double values is problematic due to rounding issues. AllOverIt provides extension methods to help compare a double with another, or zero. The built-in tolerance is defined as 1E-7 . Overloads exist that allow you to provide your own tolerance. public static bool IsZero(this double value); public static bool IsZero(this double value, double tolerance); Compares a double value to zero, within a given tolerance. public static bool IsEqualTo(this double lhs, double rhs); public static bool IsEqualTo(this double lhs, double rhs, double tolerance); Compares to double values with each other, within a given tolerance."
  },
  "library/about/dependencies.html": {
    "href": "library/about/dependencies.html",
    "title": "Dependencies | AllOverIt",
    "keywords": "Dependencies AllOverIt relies only on NETStandard.Library , version 2.03."
  },
  "library/docs/extensions/extensions_string.html": {
    "href": "library/docs/extensions/extensions_string.html",
    "title": "StringExtensions | AllOverIt",
    "keywords": "StringExtensions As<TType>() and AsNullable<TType>() public static TType As<TType>(this string value, TType defaultValue = default, bool ignoreCase = true); public static TType? AsNullable<TType>(this string value, bool ignoreCase = true) where TType : struct; Similar to methods of the same name in the objectextensions namespace, these methods attempt to convert a string to another type, typically Boolean, Integral, or Enum types. Supported conversions include byte, sbyte, decimal, double, float, int, uint, long, ulong, short, ushort, string, boolean and enum. Char conversions must be performed using the ObjectExtensions.As<TType>() method. No attempt is made to avoid overflow or argument exceptions. Other conversions are possible if a suitable TypeConverter is available. // each will return a Boolean True (a variable would // normally be in the place of the string) var result = \"true\".As<bool>(); var result = \"TRUE\".As<bool>(); var result = \"TrUe\".As<bool>(); var result = \"1\".As<bool>(); // each will return NumberStyles.Integer (a variable would // normally be in the place of the string) var result = \"7\".As<NumberStyles>(); var result = \"integer\".As<NumberStyles>(); var result = \"Integer\".As<NumberStyles>(); var result = \"INTEGER\".As<NumberStyles>();"
  },
  "library/about/whoami.html": {
    "href": "library/about/whoami.html",
    "title": "Who Am I? | AllOverIt",
    "keywords": "Who Am I? Follow @_mjfreelancing My name is Malcolm Smith and live just a few hours drive North of Sydney, Australia. I currently work as a full time C# developer using Visual Studio but also: have a strong background in C++ co-authored the C++Builder 5 Developers Guide (2000) contributed, as Chief Editor, to the C++ Builder Developers Journal (2004-2015). I am very passionate about coding to best practices using SOLID principles and strive for 100% code coverage in unit tests. In my spare time I enjoy SCUBA diving and landscape / nature photography. You can review some of my work at www.mjsmithphotography.com and on my Instagram account."
  },
  "library/about/versioning.html": {
    "href": "library/about/versioning.html",
    "title": "Versioning | AllOverIt",
    "keywords": "Versioning The version numbers of AllOverIt comply with Semantic Versioning . Given a version number in the format Major . Minor . Patch , then: A change in the Major version number indicates incompatible API changes A change in the Minor version number indicates new functionality and/or backward compatible changes A change in the Patch version number indicates backward compatible bug fixes"
  },
  "library/docs/extensions/extensions_object.html": {
    "href": "library/docs/extensions/extensions_object.html",
    "title": "ObjectExtensions | AllOverIt",
    "keywords": "ObjectExtensions GetPropertyValue() public static TValue GetPropertyValue<TValue>(this object instance, string propertyName, BindingFlags bindingFlags ); public static TValue GetPropertyValue<TValue>(this object instance, string propertyName, BindingOptions bindingOptions = BindingOptions.Default); Both versions of GetPropertyValue() use reflection to get the value of an object's property by name. The first version uses .NET's BindingFlags and the second version uses BindingOptions found in AllOverIt . public class Request { public string Token { get; set; } } // using BindingFlags var token = request.GetPropertyValue<string>(nameof(Request.Token), BindingFlags.Instance | BindingFlags.Public); // using BindingOptions (the default is BindingOptions.Default) var token = request.GetPropertyValue<string>(nameof(Request.Token)); SetPropertyValue() public static void SetPropertyValue<TValue>(this object instance, string propertyName, TValue value, BindingFlags bindingFlags); public static void SetPropertyValue<TValue>(this object instance, string propertyName, TValue value, BindingOptions bindingOptions = BindingOptions.Default); Both versions of SetPropertyValue() use reflection to set the value of an object's property by name. The first version uses .NET's BindingFlags and the second version uses BindingOptions found in AllOverIt . public class Request { public string Token { get; set; } } // using BindingFlags request.SetPropertyValue<string>(nameof(Request.Token), \"token_value\", BindingFlags.Instance | BindingFlags.Public); // using BindingOptions (the default is BindingOptions.Default) request.GetPropertyValue<string>(nameof(Request.Token), \"token_value\"); ToPropertyDictionary() public static IDictionary<string, object> ToPropertyDictionary(this object instance, bool includeNulls = false, BindingOptions bindingOptions = BindingOptions.Default); Use this method to convert any object to a dictionary of property key names mapped to their value. The default options exclude null properties and includes properties that are: Static or instance scope Abstract, virtual, or non-virtual access Public or protected visibility As<TType>() public static TType As<TType>(this object instance, TType defaultValue = default); This method will attempt to convert an object to another type. The following conversions are attempted (in the order shown): If null , returns defaultValue If TType is the same type as instance , or TType is object , or TType is a class type, but not a string , then The original reference is returned, casted to a TType . If TType is a Boolean and instance is an integral type ( byte , sbyte , short , ushort , int , uint , long , ulong ) then a zero value will be returned as False, and a value of one will be returned as True. All other values will throw an ArgumentOutOfRangeException exception. If instance is an integral value and TType is an Enum then a conversion will be attempted. If the conversion cannot be performed then an ArgumentOutOfRangeException exception will be thrown. If any of the following are true: TType is a Boolean instance is a Boolean TType is a char instance is a char Then an attempt to convert instance to TType will be performed using Convert.ChangeType() . In all other cases, instance will be converted to a string (using string interpolation) and passed to StringExtensions.As<TType>() for conversion. AsNullable<TType> public static TType? AsNullable<TType>(this object instance, TType? defaultValue = null) where TType : struct; This method behaves identical to As<TType>() . CalculateHashCode() There are two overloads, each of which are described below. public static int CalculateHashCode<TType>(this TType instance, IEnumerable<string> includeProperties = null, IEnumerable<string> excludeProperties = null); This overload uses reflection to find all instance properties and calculate a hash code. The main advantage of using reflection is that it will automatically include properties of all access (abstract, virtual, and non-virtual) and visibility (public, protected, and private). Furthermore, this overload satisfies OCP (Open-Closed Principle) because the hash code will automatically adjust the calculations if properties are added or removed. The includeProperties and excludeProperties options exist to provide finer control over which properties are considered for calculating the hash code. When includeProperties is null then all properties are included, otherwise only those specified are considered. When excludeProperties is null then no properties are excluded, otherwise the specified properties are excluded. public static int CalculateHashCode<TType>(this TType instance, params Func<TType, object>[] propertyResolvers); This overload calculates the hash code based on explicitly specified properties, fields, or the return result from a method call. If properties are added to the class then you must remember to later include those for them to be considered during the hash code calculation."
  },
  "library/docs/extensions/extensions_dictionary.html": {
    "href": "library/docs/extensions/extensions_dictionary.html",
    "title": "DictionaryExtensions | AllOverIt",
    "keywords": "DictionaryExtensions GetValueOrDefault() public static TValue GetValueOrDefault<TKey, TValue>( this IDictionary<TKey, TValue> dictionary, TKey key, TValue defaultValue = default) This extension method returns the value associated with a key if found, otherwise it returns a (optional) default value. // assuming managers is of type Dictionary<int, Person> // id is an integer identifier to look up var person = managers.GetValueOrDefault(id); If found, the associated Person instance will be returned, otherwise null . // id is an integer identifier to look up // manager is an instance of a Person object var person = managers.GetValueOrDefault(id, manager); If found, the associated Person instance will be returned, otherwise manager will be. The managers dictionary is not mutated if the key is not found. GetOrSet() public static TValue GetOrSet<TKey, TValue>( this IDictionary<TKey, TValue> dictionary, TKey key, Func<TValue> valueCreator) This extension method returns the value associated with a key if found, otherwise it invokes valueCreator to get the value that should be added to the dictionary, and then returned to the caller. // id is an integer identifier to look up // manager is an instance of a Person object var person = managers.GetValueOrDefault(id, () => manager); If found, the associated Person instance will be returned, otherwise manager will be returned after adding it to the dictionary. The managers dictionary is mutated if the key is not found."
  },
  "library/docs/extensions/extensions_comparable.html": {
    "href": "library/docs/extensions/extensions_comparable.html",
    "title": "ComparableExtensions | AllOverIt",
    "keywords": "ComparableExtensions The IComparable interface allows for one object to be custom compared to another. AllOverIt contains the following extension methods: LessThan<TType>() LessThanOrEqual<TType>() GreaterThan<TType>() GreaterThanOrEqual<TType>() EqualTo<TType>() NotEqualTo<TType>() The following example shows how to compare two Person objects based on their Surname and FirstName . public class Person : IComparable<Person> { public string FirstName { get; } public string Surname { get; } public Person(string firstName, string surname) { FirstName = firstName; Surname = surname; } public int CompareTo(Person other) { // compare by surname, then first name, case insensitively var surnameComparison = CompareName(Surname, other.Surname); return surnameComparison != 0 ? surnameComparison : CompareName(FirstName, other.FirstName); } private static int CompareName(string lhs, string rhs) { return string.Compare(lhs, rhs, StringComparison.InvariantCultureIgnoreCase); } } And this is how it can be used within a LINQ query using the extension methods available in AllOverIt . var persons = new[] { new Person(\"Adam\", \"Baker\"), new Person(\"Adam\", \"Murphy\"), new Person(\"Paul\", \"Nielson\"), new Person(\"Jon\", \"Nielson\") }; // custom comparer will consider them in the following order: // Baker, Adam // Murphy, Adam // Nielson, Jon // Nielson, Paul var comparisonPerson = new Person(\"Amy\", \"Myer\"); var actual = persons.Where( item => item.LessThan(comparisonPerson) ).AsReadOnlyList(); actual.Should().BeEquivalentTo( new Person(\"Adam\", \"Baker\"), new Person(\"Adam\", \"Murphy\") );"
  },
  "library/docs/extensions/extensions_typeinfo.html": {
    "href": "library/docs/extensions/extensions_typeinfo.html",
    "title": "TypeInfoExtensions | AllOverIt",
    "keywords": "TypeInfoExtensions public static IEnumerable<PropertyInfo> GetPropertyInfo(this TypeInfo typeInfo, bool declaredOnly = false); public static PropertyInfo GetPropertyInfo(this TypeInfo typeInfo, string propertyName); These methods are identical to those of the same name in the TypeExtensions namespace, except they extend TypeInfo instead of Type . Refer to TypeExtensions for more information."
  },
  "library/docs/extensions/extensions_propertyinfo.html": {
    "href": "library/docs/extensions/extensions_propertyinfo.html",
    "title": "PropertyInfoExtensions | AllOverIt",
    "keywords": "PropertyInfoExtensions Properties can be declared as abstract, virtual, or static, as well as public, protected, private, or internal. Extension methods exist for each of these cases: public static bool IsAbstract(this PropertyInfo propertyInfo); public static bool IsVirtual(this PropertyInfo propertyInfo); public static bool IsStatic(this PropertyInfo propertyInfo); public static bool IsPublic(this PropertyInfo propertyInfo); public static bool IsProtected(this PropertyInfo propertyInfo); public static bool IsPrivate(this PropertyInfo propertyInfo); public static bool IsInternal(this PropertyInfo propertyInfo); These extensions prove to be quite useful when used in conjunction with the TypeInfo extensions or the various methods within ReflectionHelper that return PropertyInfo . For example: public class Person { public string FirstName { get; set; } public string Surname { get; set; } public int Age { get; set; } public string FullName => $\"{FirstName} {Surname}\"; } Assume subject in the following snippet is an instance of Person : var properties = new[] { \"FirstName\", \"Surname\", \"Age\", \"FullName\" }; // Using reflection, this will output the value of each property on `subject` foreach (var property in properties) { // GetPropertyInfo() is an extension method in TypeInfoExtensions var info = typeof(Person).GetPropertyInfo(property); var value = info.GetValue(subject); Console.WriteLine($\"{property} = {value}\"); } The same info can be used to check the visibility of a property: var isPublic = info.IsPublic(); // true var isProtected = info.IsProtected(); // false var isPrivate = info.IsPrivate(); // false var isInternal = info.IsInternal(); // false Or accessibility: var isAbstract = info.IsAbstract(); // false var isVirtual = info.IsVirtual(); // false var isStatic = info.IsStatic(); // false"
  },
  "api/AllOverIt.Helpers.EnumHelper.html": {
    "href": "api/AllOverIt.Helpers.EnumHelper.html",
    "title": "Class EnumHelper | AllOverIt",
    "keywords": "Class EnumHelper Provides static, general purpose, methods related to using Enums. Inheritance System.Object EnumHelper Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Helpers Assembly : AllOverIt.dll Syntax public static class EnumHelper Methods GetEnumValues<TType>() Returns all possible enum values. Declaration public static IReadOnlyCollection<TType> GetEnumValues<TType>() where TType : struct, Enum Returns Type Description System.Collections.Generic.IReadOnlyCollection <TType> All possible enum values. Type Parameters Name Description TType The Enum type."
  },
  "api/AllOverIt.Helpers.Guard.html": {
    "href": "api/AllOverIt.Helpers.Guard.html",
    "title": "Class Guard | AllOverIt",
    "keywords": "Class Guard Inheritance System.Object Guard Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Helpers Assembly : AllOverIt.dll Syntax public static class Guard Methods WhenNotNull<TType>(TType, String) Declaration public static TType WhenNotNull<TType>(this TType argument, string name) where TType : class Parameters Type Name Description TType argument System.String name Returns Type Description TType Type Parameters Name Description TType WhenNotNull<TType>(Expression<Func<TType>>) Declaration public static TType WhenNotNull<TType>(Expression<Func<TType>> expression) where TType : class Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TType>> expression Returns Type Description TType Type Parameters Name Description TType WhenNotNullOrEmpty(Expression<Func<String>>) Declaration public static string WhenNotNullOrEmpty(Expression<Func<string>> expression) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func < System.String >> expression Returns Type Description System.String WhenNotNullOrEmpty(String, String) Declaration public static string WhenNotNullOrEmpty(this string argument, string name) Parameters Type Name Description System.String argument System.String name Returns Type Description System.String WhenNotNullOrEmpty<TType>(IEnumerable<TType>, String) Declaration public static IEnumerable<TType> WhenNotNullOrEmpty<TType>(this IEnumerable<TType> argument, string name) Parameters Type Name Description System.Collections.Generic.IEnumerable <TType> argument System.String name Returns Type Description System.Collections.Generic.IEnumerable <TType> Type Parameters Name Description TType WhenNotNullOrEmpty<TType>(Expression<Func<IEnumerable<TType>>>) Declaration public static IEnumerable<TType> WhenNotNullOrEmpty<TType>(Expression<Func<IEnumerable<TType>>> expression) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func < System.Collections.Generic.IEnumerable <TType>>> expression Returns Type Description System.Collections.Generic.IEnumerable <TType> Type Parameters Name Description TType"
  },
  "api/AllOverIt.Events.Subscription.html": {
    "href": "api/AllOverIt.Events.Subscription.html",
    "title": "Class Subscription | AllOverIt",
    "keywords": "Class Subscription Inheritance System.Object Subscription Implements ISubscription Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Events Assembly : AllOverIt.dll Syntax public class Subscription : ISubscription Constructors Subscription(Delegate) Declaration public Subscription(Delegate handler) Parameters Type Name Description System.Delegate handler Methods GetHandler<TMessage>() Declaration public Action<TMessage> GetHandler<TMessage>() Returns Type Description System.Action <TMessage> Type Parameters Name Description TMessage Handle<TMessage>(TMessage) Declaration public void Handle<TMessage>(TMessage message) Parameters Type Name Description TMessage message Type Parameters Name Description TMessage Implements ISubscription Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Extensions.StringExtensions.html": {
    "href": "api/AllOverIt.Extensions.StringExtensions.html",
    "title": "Class StringExtensions | AllOverIt",
    "keywords": "Class StringExtensions Inheritance System.Object StringExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class StringExtensions Methods As<TType>(String, TType) Converts a given string to another type. Declaration public static TType As<TType>(this string value, TType defaultValue = null) Parameters Type Name Description System.String value The value to be converted. TType defaultValue The value to return if is null, empty or contains whitespace, or is considered invalid for the TType converter. Returns Type Description TType The converted value, or the value if the conversion cannot be performed. Type Parameters Name Description TType The type to convert to. Remarks Supported conversions include byte, sbyte, decimal, double, float, int, uint, long, ulong, short, ushort, string, bool and enum. Char and Boolean type conversions must be performed using the As<TType>(Object, TType) method. No attempt is made to avoid overflow or argument exceptions. AsNullable<TType>(String) Converts a given string to another nullable type. Declaration public static TType? AsNullable<TType>(this string value) where TType : struct Parameters Type Name Description System.String value The value to be converted. Returns Type Description System.Nullable <TType> The converted value, or null if the conversion cannot be performed. Type Parameters Name Description TType The nullable type to convert to."
  },
  "api/AllOverIt.Events.WeakSubscription.html": {
    "href": "api/AllOverIt.Events.WeakSubscription.html",
    "title": "Class WeakSubscription | AllOverIt",
    "keywords": "Class WeakSubscription Inheritance System.Object WeakSubscription Implements ISubscription Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Events Assembly : AllOverIt.dll Syntax public class WeakSubscription : ISubscription Constructors WeakSubscription(Delegate) Declaration public WeakSubscription(Delegate handler) Parameters Type Name Description System.Delegate handler Methods GetHandler<TMessage>() Declaration public Action<TMessage> GetHandler<TMessage>() Returns Type Description System.Action <TMessage> Type Parameters Name Description TMessage Handle<TMessage>(TMessage) Declaration public void Handle<TMessage>(TMessage message) Parameters Type Name Description TMessage message Type Parameters Name Description TMessage Implements ISubscription Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Helpers.Raii-1.html": {
    "href": "api/AllOverIt.Helpers.Raii-1.html",
    "title": "Class Raii<TType> | AllOverIt",
    "keywords": "Class Raii<TType> A strongly-type disposable object implementing the Resource Acquisition Is Initialization idiom. Inheritance System.Object Raii<TType> Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Helpers Assembly : AllOverIt.dll Syntax public class Raii<TType> : IDisposable Type Parameters Name Description TType The type being initialized. Constructors Raii(Func<TType>, Action<TType>) Constructor used to provide the initialization and cleanup actions to be invoked. Declaration public Raii(Func<TType> initialize, Action<TType> cleanUp) Parameters Type Name Description System.Func <TType> initialize The initialization action to invoke at the time of initialization. System.Action <TType> cleanUp The cleanup action to perform when the object is disposed. Properties Context Declaration public TType Context { get; } Property Value Type Description TType Methods Dispose() This is called when the instance is being disposed. Declaration public void Dispose() Dispose(Boolean) A virtual method that is called at the time of disposal. For this class, the cleanup action provided at the time of construction is invoked. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing Is true when the object is being disposed, otherwise false. Implements System.IDisposable Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Helpers.Raii.html": {
    "href": "api/AllOverIt.Helpers.Raii.html",
    "title": "Class Raii | AllOverIt",
    "keywords": "Class Raii A disposable object implementing the Resource Acquisition Is Initialization idiom. Inheritance System.Object Raii Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Helpers Assembly : AllOverIt.dll Syntax public class Raii : IDisposable Constructors Raii(Action, Action) Constructor used to provide the initialization and cleanup actions to be invoked. Declaration public Raii(Action initialize, Action cleanUp) Parameters Type Name Description System.Action initialize The initialization action to invoke at the time of initialization. System.Action cleanUp The cleanup action to perform when the object is disposed. Methods Dispose() This is called when the instance is being disposed. Declaration public void Dispose() Dispose(Boolean) A virtual method that is called at the time of disposal. For this class, the cleanup action provided at the time of construction is invoked. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing Is true when the object is being disposed, otherwise false. Implements System.IDisposable Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Events.AsyncWeakSubscription.html": {
    "href": "api/AllOverIt.Events.AsyncWeakSubscription.html",
    "title": "Class AsyncWeakSubscription | AllOverIt",
    "keywords": "Class AsyncWeakSubscription Inheritance System.Object AsyncWeakSubscription Implements IAsyncSubscription Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Events Assembly : AllOverIt.dll Syntax public class AsyncWeakSubscription : IAsyncSubscription Constructors AsyncWeakSubscription(Delegate) Declaration public AsyncWeakSubscription(Delegate handler) Parameters Type Name Description System.Delegate handler Methods GetHandler<TMessage>() Declaration public Func<TMessage, Task> GetHandler<TMessage>() Returns Type Description System.Func <TMessage, System.Threading.Tasks.Task > Type Parameters Name Description TMessage HandleAsync<TMessage>(TMessage) Declaration public Task HandleAsync<TMessage>(TMessage message) Parameters Type Name Description TMessage message Returns Type Description System.Threading.Tasks.Task Type Parameters Name Description TMessage Implements IAsyncSubscription Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Expressions.ParameterRebinder.html": {
    "href": "api/AllOverIt.Expressions.ParameterRebinder.html",
    "title": "Class ParameterRebinder | AllOverIt",
    "keywords": "Class ParameterRebinder Inheritance System.Object System.Linq.Expressions.ExpressionVisitor ParameterRebinder Inherited Members System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection<System.Linq.Expressions.Expression>) System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression) System.Linq.Expressions.ExpressionVisitor.Visit<T>(System.Collections.ObjectModel.ReadOnlyCollection<T>, System.Func<T, T>) System.Linq.Expressions.ExpressionVisitor.VisitAndConvert<T>(T, System.String) System.Linq.Expressions.ExpressionVisitor.VisitAndConvert<T>(System.Collections.ObjectModel.ReadOnlyCollection<T>, System.String) System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression) System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression) System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock) System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression) System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression) System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression) System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression) System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression) System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit) System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression) System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression) System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression) System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression) System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression) System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget) System.Linq.Expressions.ExpressionVisitor.VisitLambda<T>(System.Linq.Expressions.Expression<T>) System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression) System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression) System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression) System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment) System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding) System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression) System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding) System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding) System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression) System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression) System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression) System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression) System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression) System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase) System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression) System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression) System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Expressions Assembly : AllOverIt.dll Syntax public class ParameterRebinder : ExpressionVisitor Methods ReplaceParameters(IDictionary<ParameterExpression, ParameterExpression>, Expression) Replaces parameter expressions in a lambda expression with alternate parameter expressions in the provided mapping. Declaration public static Expression ReplaceParameters(IDictionary<ParameterExpression, ParameterExpression> parameterMap, Expression expression) Parameters Type Name Description System.Collections.Generic.IDictionary < System.Linq.Expressions.ParameterExpression , System.Linq.Expressions.ParameterExpression > parameterMap Contains the mapping of parameter expressions to replace in the provided lambda expression. System.Linq.Expressions.Expression expression The lambda expression to have its parameter expressions replaced. Returns Type Description System.Linq.Expressions.Expression A new expression with the parameter expressions replaced. VisitParameter(ParameterExpression) Declaration protected override Expression VisitParameter(ParameterExpression parameter) Parameters Type Name Description System.Linq.Expressions.ParameterExpression parameter Returns Type Description System.Linq.Expressions.Expression Overrides System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression) Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Events.AsyncSubscription.html": {
    "href": "api/AllOverIt.Events.AsyncSubscription.html",
    "title": "Class AsyncSubscription | AllOverIt",
    "keywords": "Class AsyncSubscription Inheritance System.Object AsyncSubscription Implements IAsyncSubscription Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Events Assembly : AllOverIt.dll Syntax public class AsyncSubscription : IAsyncSubscription Constructors AsyncSubscription(Delegate) Declaration public AsyncSubscription(Delegate handler) Parameters Type Name Description System.Delegate handler Methods GetHandler<TMessage>() Declaration public Func<TMessage, Task> GetHandler<TMessage>() Returns Type Description System.Func <TMessage, System.Threading.Tasks.Task > Type Parameters Name Description TMessage HandleAsync<TMessage>(TMessage) Declaration public Task HandleAsync<TMessage>(TMessage message) Parameters Type Name Description TMessage message Returns Type Description System.Threading.Tasks.Task Type Parameters Name Description TMessage Implements IAsyncSubscription Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Expressions.html": {
    "href": "api/AllOverIt.Expressions.html",
    "title": "Namespace AllOverIt.Expressions | AllOverIt",
    "keywords": "Namespace AllOverIt.Expressions Classes ParameterRebinder PredicateBuilder"
  },
  "api/AllOverIt.Events.EventAggregator.html": {
    "href": "api/AllOverIt.Events.EventAggregator.html",
    "title": "Class EventAggregator | AllOverIt",
    "keywords": "Class EventAggregator Inheritance System.Object EventAggregator Implements IEventAggregator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Events Assembly : AllOverIt.dll Syntax public class EventAggregator : IEventAggregator Methods Publish<TMessage>(TMessage) Declaration public void Publish<TMessage>(TMessage message) Parameters Type Name Description TMessage message Type Parameters Name Description TMessage PublishAsync<TMessage>(TMessage) Declaration public Task PublishAsync<TMessage>(TMessage message) Parameters Type Name Description TMessage message Returns Type Description System.Threading.Tasks.Task Type Parameters Name Description TMessage Subscribe<TMessage>(Action<TMessage>, Boolean) Declaration public void Subscribe<TMessage>(Action<TMessage> handler, bool weakSubscription = true) Parameters Type Name Description System.Action <TMessage> handler System.Boolean weakSubscription Type Parameters Name Description TMessage Subscribe<TMessage>(Func<TMessage, Task>, Boolean) Declaration public void Subscribe<TMessage>(Func<TMessage, Task> handler, bool weakSubscription = true) Parameters Type Name Description System.Func <TMessage, System.Threading.Tasks.Task > handler System.Boolean weakSubscription Type Parameters Name Description TMessage Unsubscribe<TMessage>(Action<TMessage>) Declaration public void Unsubscribe<TMessage>(Action<TMessage> handler) Parameters Type Name Description System.Action <TMessage> handler Type Parameters Name Description TMessage Unsubscribe<TMessage>(Func<TMessage, Task>) Declaration public void Unsubscribe<TMessage>(Func<TMessage, Task> handler) Parameters Type Name Description System.Func <TMessage, System.Threading.Tasks.Task > handler Type Parameters Name Description TMessage Implements IEventAggregator Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Events.html": {
    "href": "api/AllOverIt.Events.html",
    "title": "Namespace AllOverIt.Events | AllOverIt",
    "keywords": "Namespace AllOverIt.Events Classes AsyncSubscription AsyncWeakSubscription EventAggregator Subscription WeakSubscription Interfaces IAsyncSubscription IEventAggregator ISubscription"
  },
  "api/AllOverIt.Extensions.html": {
    "href": "api/AllOverIt.Extensions.html",
    "title": "Namespace AllOverIt.Extensions | AllOverIt",
    "keywords": "Namespace AllOverIt.Extensions Classes ComparableExtensions DictionaryExtensions DoubleExtensions EnumerableExtensions ExpressionExtensions ObjectExtensions PropertyInfoExtensions StringExtensions TypeExtensions TypeInfoExtensions"
  },
  "api/AllOverIt.Tasks.AsyncLazy-1.html": {
    "href": "api/AllOverIt.Tasks.AsyncLazy-1.html",
    "title": "Class AsyncLazy<TType> | AllOverIt",
    "keywords": "Class AsyncLazy<TType> Provides support for lazy initialization using a factory that returns a Task{TType}. Inheritance System.Object System.Lazy < System.Threading.Tasks.Task <TType>> AsyncLazy<TType> Inherited Members System.Lazy<System.Threading.Tasks.Task<TType>>.ToString() System.Lazy<System.Threading.Tasks.Task<TType>>.IsValueCreated System.Lazy<System.Threading.Tasks.Task<TType>>.Value System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : AllOverIt.Tasks Assembly : AllOverIt.dll Syntax public class AsyncLazy<TType> : Lazy<Task<TType>> Type Parameters Name Description TType The type that is lazily initialized. Constructors AsyncLazy(Func<TType>) Initializes a new instance of the AsyncLazy{TType} class. When lazy initialization occurs, the specified initialization factory is executed asynchronously. Declaration public AsyncLazy(Func<TType> factory) Parameters Type Name Description System.Func <TType> factory The factory used for lazy initialization of the stored value. AsyncLazy(Func<Task<TType>>) Initializes a new instance of the AsyncLazy{TType} class. When lazy initialization occurs, the specified initialization factory is executed asynchronously. Declaration public AsyncLazy(Func<Task<TType>> factory) Parameters Type Name Description System.Func < System.Threading.Tasks.Task <TType>> factory The factory used for lazy initialization of the stored value. Methods GetAwaiter() Gets an awaiter that allows for 'await lazyProp' instead of 'await lazyProp.Value' Declaration public TaskAwaiter<TType> GetAwaiter() Returns Type Description System.Runtime.CompilerServices.TaskAwaiter <TType> An awaiter for the value being initialized. Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Tasks.html": {
    "href": "api/AllOverIt.Tasks.html",
    "title": "Namespace AllOverIt.Tasks | AllOverIt",
    "keywords": "Namespace AllOverIt.Tasks Classes AsyncLazy<TType> Provides support for lazy initialization using a factory that returns a Task{TType}. RepeatingTask TaskHelper"
  },
  "api/AllOverIt.Helpers.html": {
    "href": "api/AllOverIt.Helpers.html",
    "title": "Namespace AllOverIt.Helpers | AllOverIt",
    "keywords": "Namespace AllOverIt.Helpers Classes EnumHelper Provides static, general purpose, methods related to using Enums. Guard Raii A disposable object implementing the Resource Acquisition Is Initialization idiom. Raii<TType> A strongly-type disposable object implementing the Resource Acquisition Is Initialization idiom."
  },
  "api/AllOverIt.Extensions.ObjectExtensions.html": {
    "href": "api/AllOverIt.Extensions.ObjectExtensions.html",
    "title": "Class ObjectExtensions | AllOverIt",
    "keywords": "Class ObjectExtensions Inheritance System.Object ObjectExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class ObjectExtensions Properties DefaultHashCodeBindings Specifies the binding options to use when calculating the hash code of an object when using CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) . Declaration public static BindingOptions DefaultHashCodeBindings { get; set; } Property Value Type Description BindingOptions Methods As<TType>(Object, TType) Converts the provided source instance to a specified type. Declaration public static TType As<TType>(this object instance, TType defaultValue = null) Parameters Type Name Description System.Object instance The object instance to be converted. TType defaultValue The default value to be returned when instance is null. Returns Type Description TType Returns instance converted to the specified . Type Parameters Name Description TType The type that instance is to be converted to. AsNullable<TType>(Object, Nullable<TType>) Converts the provided source instance to a specified nullable type. Declaration public static TType? AsNullable<TType>(this object instance, TType? defaultValue = default(TType? )) where TType : struct Parameters Type Name Description System.Object instance The object instance to be converted. System.Nullable <TType> defaultValue The default value to be returned when instance is null. Returns Type Description System.Nullable <TType> Returns instance converted to the specified . Type Parameters Name Description TType The (nullable) type that instance is to be converted to. CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) Uses reflection to find all instance properties and use them to calculate a hash code. Declaration public static int CalculateHashCode<TType>(this TType instance, IEnumerable<string> includeProperties = null, IEnumerable<string> excludeProperties = null) Parameters Type Name Description TType instance The instance having its hash code calculated. System.Collections.Generic.IEnumerable < System.String > includeProperties The property names to include. If null, then all non-static properties are used. System.Collections.Generic.IEnumerable < System.String > excludeProperties The property names to exclude. If null, then no properties are excluded. Returns Type Description System.Int32 The calculated hash code. Type Parameters Name Description TType The object type. Remarks To ensure idempotency, the properties are ordered by their name before calculating the hash. CalculateHashCode<TType>(TType, Func<TType, Object>[]) Calculates the hash code based on explicitly specified properties, fields, or the return result from a method call. Declaration public static int CalculateHashCode<TType>(this TType instance, params Func<TType, object>[] resolvers) Parameters Type Name Description TType instance The instance having its hash code calculated. System.Func <TType, System.Object >[] resolvers One or more resolvers that provide the properties, fields, or method calls used to calculate the hash code. Returns Type Description System.Int32 The calculated hash code. Type Parameters Name Description TType The object type. GetPropertyValue<TValue>(Object, String, BindingOptions) Uses reflection to get the value of an object's property by name. Declaration public static TValue GetPropertyValue<TValue>(this object instance, string propertyName, BindingOptions bindingOptions = BindingOptions.Static | BindingOptions.Instance | BindingOptions.Abstract | BindingOptions.Virtual | BindingOptions.NonVirtual | BindingOptions.Protected | BindingOptions.Public | BindingOptions.DefaultScope | BindingOptions.DefaultAccessor | BindingOptions.DefaultVisibility | BindingOptions.Default | BindingOptions.AllScope | BindingOptions.AllAccessor) Parameters Type Name Description System.Object instance The object to get the property value. System.String propertyName The property name. BindingOptions bindingOptions Binding options that determine how property names are resolved. Returns Type Description TValue The value of a property by name Type Parameters Name Description TValue The property type. Exceptions Type Condition System.MemberAccessException When the property name cannot be found using the provided binding options. GetPropertyValue<TValue>(Object, String, BindingFlags) Uses reflection to get the value of an object's property by name. Declaration public static TValue GetPropertyValue<TValue>(this object instance, string propertyName, BindingFlags bindingFlags) Parameters Type Name Description System.Object instance The object to get the property value. System.String propertyName The property name. System.Reflection.BindingFlags bindingFlags .NET binding options that determine how property names are resolved. Returns Type Description TValue The value of a property by name Type Parameters Name Description TValue The property type. Exceptions Type Condition System.MemberAccessException When the property name cannot be found using the provided binding flags. IsIntegral(Object) Determines if the specified object is an integral type (signed or unsigned). Declaration public static bool IsIntegral(this object instance) Parameters Type Name Description System.Object instance The object instance to be compared to an integral type. Returns Type Description System.Boolean Returns true if the specified object is an integral type (signed or unsigned). SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) Uses reflection to set the value of an object's property by name. Declaration public static void SetPropertyValue<TValue>(this object instance, string propertyName, TValue value, BindingOptions bindingOptions = BindingOptions.Static | BindingOptions.Instance | BindingOptions.Abstract | BindingOptions.Virtual | BindingOptions.NonVirtual | BindingOptions.Protected | BindingOptions.Public | BindingOptions.DefaultScope | BindingOptions.DefaultAccessor | BindingOptions.DefaultVisibility | BindingOptions.Default | BindingOptions.AllScope | BindingOptions.AllAccessor) Parameters Type Name Description System.Object instance The object to get the property value. System.String propertyName The property name. TValue value The value to set on the property. BindingOptions bindingOptions Binding options that determine how property names are resolved. Type Parameters Name Description TValue The property type. Exceptions Type Condition System.MemberAccessException When the property name cannot be found using the provided binding options. SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) Uses reflection to set the value of an object's property by name. Declaration public static void SetPropertyValue<TValue>(this object instance, string propertyName, TValue value, BindingFlags bindingFlags) Parameters Type Name Description System.Object instance The object to get the property value. System.String propertyName The property name. TValue value System.Reflection.BindingFlags bindingFlags .NET binding options that determine how property names are resolved. Type Parameters Name Description TValue The property type. Exceptions Type Condition System.MemberAccessException When the property name cannot be found using the provided binding flags. ToPropertyDictionary(Object, Boolean, BindingOptions) Creates a dictionary containing property names and associated values. Declaration public static IDictionary<string, object> ToPropertyDictionary(this object instance, bool includeNulls = false, BindingOptions bindingOptions = BindingOptions.Static | BindingOptions.Instance | BindingOptions.Abstract | BindingOptions.Virtual | BindingOptions.NonVirtual | BindingOptions.Protected | BindingOptions.Public | BindingOptions.DefaultScope | BindingOptions.DefaultAccessor | BindingOptions.DefaultVisibility | BindingOptions.Default | BindingOptions.AllScope | BindingOptions.AllAccessor) Parameters Type Name Description System.Object instance The object instance to obtain property names and values from. System.Boolean includeNulls If true then null value properties will be returned, otherwise they will be omitted. BindingOptions bindingOptions Binding options that determine how property names are resolved. Returns Type Description System.Collections.Generic.IDictionary < System.String , System.Object > Returns a dictionary containing property names and associated values."
  },
  "api/AllOverIt.Extensions.TypeInfoExtensions.html": {
    "href": "api/AllOverIt.Extensions.TypeInfoExtensions.html",
    "title": "Class TypeInfoExtensions | AllOverIt",
    "keywords": "Class TypeInfoExtensions Inheritance System.Object TypeInfoExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class TypeInfoExtensions Methods GetPropertyInfo(TypeInfo, Boolean) Gets all System.Reflection.PropertyInfo (property metadata) for a given System.Reflection.TypeInfo . Declaration public static IEnumerable<PropertyInfo> GetPropertyInfo(this TypeInfo typeInfo, bool declaredOnly = false) Parameters Type Name Description System.Reflection.TypeInfo typeInfo The System.Reflection.TypeInfo to obtain all property metadata. System.Boolean declaredOnly If true, the metadata of properties in the declared class as well as base class(es) are returned (if a property is overriden then only the base class System.Reflection.PropertyInfo is returned). If false, only property metadata of the declared type is returned. Returns Type Description System.Collections.Generic.IEnumerable < System.Reflection.PropertyInfo > The property metadata, as System.Reflection.PropertyInfo , of a provided System.Reflection.TypeInfo . Remarks When class inheritance is involved, this method returns the first property found, starting at the type represented by . GetPropertyInfo(TypeInfo, String) Gets the System.Reflection.PropertyInfo (property metadata) for a given public or protected property on a System.Reflection.TypeInfo . Declaration public static PropertyInfo GetPropertyInfo(this TypeInfo typeInfo, string propertyName) Parameters Type Name Description System.Reflection.TypeInfo typeInfo The System.Reflection.TypeInfo to obtain the property metadata from. System.String propertyName The name of the property to obtain metadata for. Returns Type Description System.Reflection.PropertyInfo The property metadata, as System.Reflection.PropertyInfo , of a specified property on the provided . Remarks When class inheritance is involved, this method returns the first property found, starting at the type represented by . If the property is overriden, this means the base class System.Reflection.PropertyInfo will not be returned. If you require the base class System.Reflection.PropertyInfo then use the GetPropertyInfo(TypeInfo, Boolean) method."
  },
  "api/AllOverIt.Reflection.html": {
    "href": "api/AllOverIt.Reflection.html",
    "title": "Namespace AllOverIt.Reflection | AllOverIt",
    "keywords": "Namespace AllOverIt.Reflection Classes ReflectionHelper Enums BindingOptions"
  },
  "api/AllOverIt.Expressions.PredicateBuilder.html": {
    "href": "api/AllOverIt.Expressions.PredicateBuilder.html",
    "title": "Class PredicateBuilder | AllOverIt",
    "keywords": "Class PredicateBuilder Inheritance System.Object PredicateBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Expressions Assembly : AllOverIt.dll Syntax public static class PredicateBuilder Methods And<TType>(Expression<Func<TType, Boolean>>, Expression<Func<TType, Boolean>>) Declaration public static Expression<Func<TType, bool>> And<TType>(this Expression<Func<TType, bool>> expression1, Expression<Func<TType, bool>> expression2) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> expression1 System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> expression2 Returns Type Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> Type Parameters Name Description TType False<TType>() Declaration public static Expression<Func<TType, bool>> False<TType>() Returns Type Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> Type Parameters Name Description TType Not<TType>(Expression<Func<TType, Boolean>>) Declaration public static Expression<Func<TType, bool>> Not<TType>(this Expression<Func<TType, bool>> expression) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> expression Returns Type Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> Type Parameters Name Description TType Or<TType>(Expression<Func<TType, Boolean>>, Expression<Func<TType, Boolean>>) Declaration public static Expression<Func<TType, bool>> Or<TType>(this Expression<Func<TType, bool>> expression1, Expression<Func<TType, bool>> expression2) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> expression1 System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> expression2 Returns Type Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> Type Parameters Name Description TType True<TType>() Declaration public static Expression<Func<TType, bool>> True<TType>() Returns Type Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> Type Parameters Name Description TType Where<TType>(Boolean) Declaration public static Expression<Func<TType, bool>> Where<TType>(bool initialState) Parameters Type Name Description System.Boolean initialState Returns Type Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> Type Parameters Name Description TType Where<TType>(Expression<Func<TType, Boolean>>) Declaration public static Expression<Func<TType, bool>> Where<TType>(Expression<Func<TType, bool>> expression) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> expression Returns Type Description System.Linq.Expressions.Expression < System.Func <TType, System.Boolean >> Type Parameters Name Description TType"
  },
  "api/AllOverIt.Extensions.EnumerableExtensions.html": {
    "href": "api/AllOverIt.Extensions.EnumerableExtensions.html",
    "title": "Class EnumerableExtensions | AllOverIt",
    "keywords": "Class EnumerableExtensions Inheritance System.Object EnumerableExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class EnumerableExtensions Methods AsList<TType>(IEnumerable<TType>) Declaration public static IList<TType> AsList<TType>(this IEnumerable<TType> items) Parameters Type Name Description System.Collections.Generic.IEnumerable <TType> items Returns Type Description System.Collections.Generic.IList <TType> Type Parameters Name Description TType AsReadOnlyCollection<TType>(IEnumerable<TType>) Declaration public static IReadOnlyCollection<TType> AsReadOnlyCollection<TType>(this IEnumerable<TType> items) Parameters Type Name Description System.Collections.Generic.IEnumerable <TType> items Returns Type Description System.Collections.Generic.IReadOnlyCollection <TType> Type Parameters Name Description TType AsReadOnlyList<TType>(IEnumerable<TType>) Declaration public static IReadOnlyList<TType> AsReadOnlyList<TType>(this IEnumerable<TType> items) Parameters Type Name Description System.Collections.Generic.IEnumerable <TType> items Returns Type Description System.Collections.Generic.IReadOnlyList <TType> Type Parameters Name Description TType Batch<TSource>(IEnumerable<TSource>, Int32) Partitions a collection into multiple batches of a maximum size. Declaration public static IEnumerable<IEnumerable<TSource>> Batch<TSource>(this IEnumerable<TSource> items, int batchSize) Parameters Type Name Description System.Collections.Generic.IEnumerable <TSource> items The source of items to be partitioned. System.Int32 batchSize The maximum number of items in each batch. Returns Type Description System.Collections.Generic.IEnumerable < System.Collections.Generic.IEnumerable <TSource>> One or more batches containing the source items partitioned into a maximum batch size. Type Parameters Name Description TSource The type stored in the source collection. IsNullOrEmpty(IEnumerable) Applicable to strings and collections, this method determines if the instance is null or empty. Declaration public static bool IsNullOrEmpty(this IEnumerable items) Parameters Type Name Description System.Collections.IEnumerable items The object of interest. Returns Type Description System.Boolean True if the object is null or empty."
  },
  "api/AllOverIt.Extensions.TypeExtensions.html": {
    "href": "api/AllOverIt.Extensions.TypeExtensions.html",
    "title": "Class TypeExtensions | AllOverIt",
    "keywords": "Class TypeExtensions Inheritance System.Object TypeExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class TypeExtensions Methods GetFriendlyName(Type) A utility method that returns a print-friendly name for a given type. Declaration public static string GetFriendlyName(this Type type) Parameters Type Name Description System.Type type The type to generate a print-friendly name for. Returns Type Description System.String A print-friendly name for a given type. GetGenericArguments(Type) Gets an array of the generic type arguments for this type. Declaration public static IEnumerable<Type> GetGenericArguments(this Type type) Parameters Type Name Description System.Type type The System.Type containing the generic type arguments. Returns Type Description System.Collections.Generic.IEnumerable < System.Type > An array of the generic type arguments for this type. GetMethodInfo(Type, BindingOptions, Boolean) Gets System.Reflection.MethodInfo (method metadata) for a given System.Type and binding option. Declaration public static IEnumerable<MethodInfo> GetMethodInfo(this Type type, BindingOptions binding = BindingOptions.Static | BindingOptions.Instance | BindingOptions.Abstract | BindingOptions.Virtual | BindingOptions.NonVirtual | BindingOptions.Protected | BindingOptions.Public | BindingOptions.DefaultScope | BindingOptions.DefaultAccessor | BindingOptions.DefaultVisibility | BindingOptions.Default | BindingOptions.AllScope | BindingOptions.AllAccessor, bool declaredOnly = false) Parameters Type Name Description System.Type type The type to obtain method metadata for. BindingOptions binding The binding option that determines the scope, access, and visibility rules to apply when searching for the metadata. System.Boolean declaredOnly If true, the metadata of properties in the declared class as well as base class(es) are returned. If false, only method metadata of the declared type is returned. Returns Type Description System.Collections.Generic.IEnumerable < System.Reflection.MethodInfo > The method metadata, as System.Reflection.MethodInfo , of a provided System.Type . Remarks When class inheritance is involved, this method returns the first method found, starting at the type represented by . GetMethodInfo(Type, String) Gets System.Reflection.MethodInfo (method metadata) for a given System.Type method with a given name and no arguments. Declaration public static MethodInfo GetMethodInfo(this Type type, string name) Parameters Type Name Description System.Type type The type to obtain method metadata for. System.String name The name of the method. Returns Type Description System.Reflection.MethodInfo The method metadata, as System.Reflection.MethodInfo , of a provided System.Type with a given name and no arguments. Remarks All instance, static, public, and non-public methods are searched. GetMethodInfo(Type, String, Type[]) Gets System.Reflection.MethodInfo (method metadata) for a given System.Type method with a given name and argument types. Declaration public static MethodInfo GetMethodInfo(this Type type, string name, Type[] types) Parameters Type Name Description System.Type type The type to obtain method metadata for. System.String name The name of the method. System.Type [] types The argument types expected on the method Returns Type Description System.Reflection.MethodInfo The method metadata, as System.Reflection.MethodInfo , of a provided System.Type with a given name and argument types. Remarks All instance, static, public, and non-public methods are searched. GetPropertyInfo(Type, BindingOptions, Boolean) Gets System.Reflection.PropertyInfo (property metadata) for all properties on a given System.Type satisfying a given binding option. Declaration public static IEnumerable<PropertyInfo> GetPropertyInfo(this Type type, BindingOptions binding = BindingOptions.Static | BindingOptions.Instance | BindingOptions.Abstract | BindingOptions.Virtual | BindingOptions.NonVirtual | BindingOptions.Protected | BindingOptions.Public | BindingOptions.DefaultScope | BindingOptions.DefaultAccessor | BindingOptions.DefaultVisibility | BindingOptions.Default | BindingOptions.AllScope | BindingOptions.AllAccessor, bool declaredOnly = false) Parameters Type Name Description System.Type type The type to obtain property metadata for. BindingOptions binding The binding option that determines the scope, access, and visibility rules to apply when searching for the metadata. System.Boolean declaredOnly If true, the metadata of properties in the declared class as well as base class(es) are returned. If false, only property metadata of the declared type is returned. Returns Type Description System.Collections.Generic.IEnumerable < System.Reflection.PropertyInfo > The property metadata, as System.Reflection.PropertyInfo , of a provided System.Type . Remarks When class inheritance is involved, this method returns the first property found, starting at the type represented by . GetPropertyInfo(Type, String) Gets the System.Reflection.PropertyInfo (property metadata) for a given public or protected property on a System.Type . Declaration public static PropertyInfo GetPropertyInfo(this Type type, string propertyName) Parameters Type Name Description System.Type type The System.Type to obtain the property metadata from. System.String propertyName The name of the property to obtain metadata for. Returns Type Description System.Reflection.PropertyInfo The property metadata, as System.Reflection.PropertyInfo , of a specified property on the provided . Remarks When class inheritance is involved, this method returns the first property found, starting at the type represented by . IsAssignableFromType(Type, Type) Indicates if another type can be assigned to the current type. Declaration public static bool IsAssignableFromType(this Type type, Type fromType) Parameters Type Name Description System.Type type The current type. System.Type fromType The type to check. Returns Type Description System.Boolean True if the can be assigned to the current type, otherwise false. IsClassType(Type) Indicates if the System.Type represents a class type. Declaration public static bool IsClassType(this Type type) Parameters Type Name Description System.Type type The type to compare. Returns Type Description System.Boolean True if the System.Type represents a class type, otherwise false. IsEnumerableType(Type, Boolean) Indicates if the System.Type represents an enumerable type. Declaration public static bool IsEnumerableType(this Type type, bool includeString = false) Parameters Type Name Description System.Type type The type to compare. System.Boolean includeString Indicates if a string type should be considered as an enumerable (of char). Returns Type Description System.Boolean True if the System.Type represents an enumerable type, otherwise false. IsEnumType(Type) Indicates if the System.Type represents an enumeration type. Declaration public static bool IsEnumType(this Type type) Parameters Type Name Description System.Type type The type to compare. Returns Type Description System.Boolean True if the System.Type represents an enumeration type, otherwise false. IsFloatingType(Type) Indicates if the System.Type represents a floating type. Declaration public static bool IsFloatingType(this Type type) Parameters Type Name Description System.Type type The type to compare. Returns Type Description System.Boolean True if the System.Type represents a floating type, otherwise false. IsGenericEnumerableType(Type) Indicates if the System.Type represents a generic enumerable type. Declaration public static bool IsGenericEnumerableType(this Type type) Parameters Type Name Description System.Type type The type to compare. Returns Type Description System.Boolean True if the System.Type represents a generic enumerable type, otherwise false. IsGenericNullableType(Type) Indicates if the System.Type represents a generic nullable type. Declaration public static bool IsGenericNullableType(this Type type) Parameters Type Name Description System.Type type The type to compare. Returns Type Description System.Boolean True if the System.Type represents a generic nullable type, otherwise false. IsGenericType(Type) Indicates if the System.Type represents a generic type. Declaration public static bool IsGenericType(this Type type) Parameters Type Name Description System.Type type The type to compare. Returns Type Description System.Boolean True if the System.Type represents a generic type, otherwise false. IsIntegralType(Type) Indicates if the System.Type represents an integral type. Declaration public static bool IsIntegralType(this Type type) Parameters Type Name Description System.Type type The type to compare. Returns Type Description System.Boolean True if the System.Type represents an integral type, otherwise false. IsPrimitiveType(Type) Indicates if the System.Type represents a primitive type. Declaration public static bool IsPrimitiveType(this Type type) Parameters Type Name Description System.Type type The type to compare. Returns Type Description System.Boolean True if the System.Type represents a primitive type, otherwise false."
  },
  "api/AllOverIt.Extensions.PropertyInfoExtensions.html": {
    "href": "api/AllOverIt.Extensions.PropertyInfoExtensions.html",
    "title": "Class PropertyInfoExtensions | AllOverIt",
    "keywords": "Class PropertyInfoExtensions Inheritance System.Object PropertyInfoExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class PropertyInfoExtensions Methods IsAbstract(PropertyInfo) Determines if the provided propertyInfo is for an abstract property. Declaration public static bool IsAbstract(this PropertyInfo propertyInfo) Parameters Type Name Description System.Reflection.PropertyInfo propertyInfo The System.Reflection.PropertyInfo for a property. Returns Type Description System.Boolean True if the propertyInfo is for an abstract property, otherwise false. IsInternal(PropertyInfo) Determines of the propertyInfo is for an internal property. Declaration public static bool IsInternal(this PropertyInfo propertyInfo) Parameters Type Name Description System.Reflection.PropertyInfo propertyInfo The System.Reflection.PropertyInfo for a property. Returns Type Description System.Boolean True if the propertyInfo is for an internal property, otherwise false. IsPrivate(PropertyInfo) Determines of the propertyInfo is for a private property. Declaration public static bool IsPrivate(this PropertyInfo propertyInfo) Parameters Type Name Description System.Reflection.PropertyInfo propertyInfo The System.Reflection.PropertyInfo for a property. Returns Type Description System.Boolean True if the propertyInfo is for a virtual property, otherwise false. IsProtected(PropertyInfo) Determines of the propertyInfo is for a protected property. Declaration public static bool IsProtected(this PropertyInfo propertyInfo) Parameters Type Name Description System.Reflection.PropertyInfo propertyInfo The System.Reflection.PropertyInfo for a property. Returns Type Description System.Boolean True if the propertyInfo is for a protected property, otherwise false. IsPublic(PropertyInfo) Determines of the propertyInfo is for a public property. Declaration public static bool IsPublic(this PropertyInfo propertyInfo) Parameters Type Name Description System.Reflection.PropertyInfo propertyInfo The System.Reflection.PropertyInfo for a property. Returns Type Description System.Boolean True if the propertyInfo is for a public property, otherwise false. IsStatic(PropertyInfo) Determines of the propertyInfo is for a static property. Declaration public static bool IsStatic(this PropertyInfo propertyInfo) Parameters Type Name Description System.Reflection.PropertyInfo propertyInfo The System.Reflection.PropertyInfo for a property. Returns Type Description System.Boolean True if the propertyInfo is for a static property, otherwise false. IsVirtual(PropertyInfo) Determines of the propertyInfo is for a virtual property. Declaration public static bool IsVirtual(this PropertyInfo propertyInfo) Parameters Type Name Description System.Reflection.PropertyInfo propertyInfo The System.Reflection.PropertyInfo for a property. Returns Type Description System.Boolean True if the propertyInfo is for a virtual property, otherwise false."
  },
  "api/AllOverIt.Extensions.DictionaryExtensions.html": {
    "href": "api/AllOverIt.Extensions.DictionaryExtensions.html",
    "title": "Class DictionaryExtensions | AllOverIt",
    "keywords": "Class DictionaryExtensions Inheritance System.Object DictionaryExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class DictionaryExtensions Methods GetOrSet<TKey, TValue>(IDictionary<TKey, TValue>, TKey, Func<TValue>) Declaration public static TValue GetOrSet<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, Func<TValue> valueCreator) Parameters Type Name Description System.Collections.Generic.IDictionary <TKey, TValue> dictionary TKey key System.Func <TValue> valueCreator Returns Type Description TValue Type Parameters Name Description TKey TValue GetValueOrDefault<TKey, TValue>(IDictionary<TKey, TValue>, TKey, TValue) Declaration public static TValue GetValueOrDefault<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, TValue defaultValue = null) Parameters Type Name Description System.Collections.Generic.IDictionary <TKey, TValue> dictionary TKey key TValue defaultValue Returns Type Description TValue Type Parameters Name Description TKey TValue"
  },
  "api/AllOverIt.Reflection.BindingOptions.html": {
    "href": "api/AllOverIt.Reflection.BindingOptions.html",
    "title": "Enum BindingOptions | AllOverIt",
    "keywords": "Enum BindingOptions Namespace : AllOverIt.Reflection Assembly : AllOverIt.dll Syntax [Flags] public enum BindingOptions Fields Name Description Abstract Filter reflection operations to abstract access. All Filter reflection operations to use AllScope scope, AllAccessor access, and AllVisibility visibility. AllAccessor Filter reflection operations to abstract , virtual , or non-virtual access. AllScope Filter reflection operations to static or instance scope. AllVisibility Filter reflection operations to public , protected , private , or internal access. Default Filter reflection operations to use DefaultScope scope, DefaultAccessor access, and DefaultVisibility visibility. DefaultAccessor Filter reflection operations to abstract , virtual , or non-virtual access. DefaultScope Filter reflection operations to static or instance scope. DefaultVisibility Filter reflection operations to public or protected access. Instance Filter reflection operations to instance (non-static) scope. Internal Filter reflection operations to internal visibility. NonVirtual Filter reflection operations to a non-virtual access. Private Filter reflection operations to private visibility. Protected Filter reflection operations to protected visibility. Public Filter reflection operations to public visibility. Static Filter reflection operations to static scope. Virtual Filter reflection operations to virtual access. Extension Methods ObjectExtensions.ToPropertyDictionary(Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(String, TValue, BindingOptions) ObjectExtensions.IsIntegral() ObjectExtensions.As<TType>(TType) ObjectExtensions.AsNullable<TType>(Nullable<TType>) ObjectExtensions.CalculateHashCode<BindingOptions>(IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<BindingOptions>(Func<BindingOptions, Object>[])"
  },
  "api/AllOverIt.Extensions.DoubleExtensions.html": {
    "href": "api/AllOverIt.Extensions.DoubleExtensions.html",
    "title": "Class DoubleExtensions | AllOverIt",
    "keywords": "Class DoubleExtensions Inheritance System.Object DoubleExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class DoubleExtensions Methods IsEqualTo(Double, Double) Declaration public static bool IsEqualTo(this double lhs, double rhs) Parameters Type Name Description System.Double lhs System.Double rhs Returns Type Description System.Boolean IsEqualTo(Double, Double, Double) Declaration public static bool IsEqualTo(this double lhs, double rhs, double tolerance) Parameters Type Name Description System.Double lhs System.Double rhs System.Double tolerance Returns Type Description System.Boolean IsZero(Double) Declaration public static bool IsZero(this double value) Parameters Type Name Description System.Double value Returns Type Description System.Boolean IsZero(Double, Double) Declaration public static bool IsZero(this double value, double tolerance) Parameters Type Name Description System.Double value System.Double tolerance Returns Type Description System.Boolean"
  },
  "api/AllOverIt.Events.ISubscription.html": {
    "href": "api/AllOverIt.Events.ISubscription.html",
    "title": "Interface ISubscription | AllOverIt",
    "keywords": "Interface ISubscription Namespace : AllOverIt.Events Assembly : AllOverIt.dll Syntax public interface ISubscription Methods GetHandler<TMessage>() Declaration Action<TMessage> GetHandler<TMessage>() Returns Type Description System.Action <TMessage> Type Parameters Name Description TMessage Handle<TMessage>(TMessage) Declaration void Handle<TMessage>(TMessage message) Parameters Type Name Description TMessage message Type Parameters Name Description TMessage Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Events.IAsyncSubscription.html": {
    "href": "api/AllOverIt.Events.IAsyncSubscription.html",
    "title": "Interface IAsyncSubscription | AllOverIt",
    "keywords": "Interface IAsyncSubscription Namespace : AllOverIt.Events Assembly : AllOverIt.dll Syntax public interface IAsyncSubscription Methods GetHandler<TMessage>() Declaration Func<TMessage, Task> GetHandler<TMessage>() Returns Type Description System.Func <TMessage, System.Threading.Tasks.Task > Type Parameters Name Description TMessage HandleAsync<TMessage>(TMessage) Declaration Task HandleAsync<TMessage>(TMessage message) Parameters Type Name Description TMessage message Returns Type Description System.Threading.Tasks.Task Type Parameters Name Description TMessage Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Tasks.TaskHelper.html": {
    "href": "api/AllOverIt.Tasks.TaskHelper.html",
    "title": "Class TaskHelper | AllOverIt",
    "keywords": "Class TaskHelper Inheritance System.Object TaskHelper Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Tasks Assembly : AllOverIt.dll Syntax public static class TaskHelper Methods WhenAll<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Task<T1>, Task<T2>, Task<T3>, Task<T4>, Task<T5>, Task<T6>, Task<T7>, Task<T8>, Task<T9>, Task<T10>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> WhenAll<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Task<T1> task1, Task<T2> task2, Task<T3> task3, Task<T4> task4, Task<T5> task5, Task<T6> task6, Task<T7> task7, Task<T8> task8, Task<T9> task9, Task<T10> task10, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Threading.Tasks.Task <T3> task3 The third task System.Threading.Tasks.Task <T4> task4 The fourth task System.Threading.Tasks.Task <T5> task5 The fifth task System.Threading.Tasks.Task <T6> task6 The sixth task System.Threading.Tasks.Task <T7> task7 The seventh task System.Threading.Tasks.Task <T8> task8 The eighth task System.Threading.Tasks.Task <T9> task9 The ninth task System.Threading.Tasks.Task <T10> task10 The tenth task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2, T3, T4, T5, T6, T7, System.ValueTuple <T8, T9, T10>>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 T3 The result type returned by task3 T4 The result type returned by task4 T5 The result type returned by task5 T6 The result type returned by task6 T7 The result type returned by task7 T8 The result type returned by task8 T9 The result type returned by task9 T10 The result type returned by task10 WhenAll<T1, T2>(Task<T1>, Task<T2>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2)> WhenAll<T1, T2>(Task<T1> task1, Task<T2> task2, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 WhenAll<T1, T2, T3>(Task<T1>, Task<T2>, Task<T3>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2, T3)> WhenAll<T1, T2, T3>(Task<T1> task1, Task<T2> task2, Task<T3> task3, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Threading.Tasks.Task <T3> task3 The third task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2, T3>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 T3 The result type returned by task3 WhenAll<T1, T2, T3, T4>(Task<T1>, Task<T2>, Task<T3>, Task<T4>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2, T3, T4)> WhenAll<T1, T2, T3, T4>(Task<T1> task1, Task<T2> task2, Task<T3> task3, Task<T4> task4, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Threading.Tasks.Task <T3> task3 The third task System.Threading.Tasks.Task <T4> task4 The fourth task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2, T3, T4>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 T3 The result type returned by task3 T4 The result type returned by task4 WhenAll<T1, T2, T3, T4, T5>(Task<T1>, Task<T2>, Task<T3>, Task<T4>, Task<T5>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2, T3, T4, T5)> WhenAll<T1, T2, T3, T4, T5>(Task<T1> task1, Task<T2> task2, Task<T3> task3, Task<T4> task4, Task<T5> task5, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Threading.Tasks.Task <T3> task3 The third task System.Threading.Tasks.Task <T4> task4 The fourth task System.Threading.Tasks.Task <T5> task5 The fifth task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2, T3, T4, T5>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 T3 The result type returned by task3 T4 The result type returned by task4 T5 The result type returned by task5 WhenAll<T1, T2, T3, T4, T5, T6>(Task<T1>, Task<T2>, Task<T3>, Task<T4>, Task<T5>, Task<T6>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2, T3, T4, T5, T6)> WhenAll<T1, T2, T3, T4, T5, T6>(Task<T1> task1, Task<T2> task2, Task<T3> task3, Task<T4> task4, Task<T5> task5, Task<T6> task6, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Threading.Tasks.Task <T3> task3 The third task System.Threading.Tasks.Task <T4> task4 The fourth task System.Threading.Tasks.Task <T5> task5 The fifth task System.Threading.Tasks.Task <T6> task6 The sixth task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2, T3, T4, T5, T6>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 T3 The result type returned by task3 T4 The result type returned by task4 T5 The result type returned by task5 T6 The result type returned by task6 WhenAll<T1, T2, T3, T4, T5, T6, T7>(Task<T1>, Task<T2>, Task<T3>, Task<T4>, Task<T5>, Task<T6>, Task<T7>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2, T3, T4, T5, T6, T7)> WhenAll<T1, T2, T3, T4, T5, T6, T7>(Task<T1> task1, Task<T2> task2, Task<T3> task3, Task<T4> task4, Task<T5> task5, Task<T6> task6, Task<T7> task7, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Threading.Tasks.Task <T3> task3 The third task System.Threading.Tasks.Task <T4> task4 The fourth task System.Threading.Tasks.Task <T5> task5 The fifth task System.Threading.Tasks.Task <T6> task6 The sixth task System.Threading.Tasks.Task <T7> task7 The seventh task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2, T3, T4, T5, T6, T7>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 T3 The result type returned by task3 T4 The result type returned by task4 T5 The result type returned by task5 T6 The result type returned by task6 T7 The result type returned by task7 WhenAll<T1, T2, T3, T4, T5, T6, T7, T8>(Task<T1>, Task<T2>, Task<T3>, Task<T4>, Task<T5>, Task<T6>, Task<T7>, Task<T8>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2, T3, T4, T5, T6, T7, T8)> WhenAll<T1, T2, T3, T4, T5, T6, T7, T8>(Task<T1> task1, Task<T2> task2, Task<T3> task3, Task<T4> task4, Task<T5> task5, Task<T6> task6, Task<T7> task7, Task<T8> task8, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Threading.Tasks.Task <T3> task3 The third task System.Threading.Tasks.Task <T4> task4 The fourth task System.Threading.Tasks.Task <T5> task5 The fifth task System.Threading.Tasks.Task <T6> task6 The sixth task System.Threading.Tasks.Task <T7> task7 The seventh task System.Threading.Tasks.Task <T8> task8 The eighth task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2, T3, T4, T5, T6, T7, System.ValueTuple <T8>>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 T3 The result type returned by task3 T4 The result type returned by task4 T5 The result type returned by task5 T6 The result type returned by task6 T7 The result type returned by task7 T8 The result type returned by task8 WhenAll<T1, T2, T3, T4, T5, T6, T7, T8, T9>(Task<T1>, Task<T2>, Task<T3>, Task<T4>, Task<T5>, Task<T6>, Task<T7>, Task<T8>, Task<T9>, Boolean) Waits for all the tasks to complete and returns their results. Declaration public static Task<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> WhenAll<T1, T2, T3, T4, T5, T6, T7, T8, T9>(Task<T1> task1, Task<T2> task2, Task<T3> task3, Task<T4> task4, Task<T5> task5, Task<T6> task6, Task<T7> task7, Task<T8> task8, Task<T9> task9, bool continueOnCapturedContext = false) Parameters Type Name Description System.Threading.Tasks.Task <T1> task1 The first task System.Threading.Tasks.Task <T2> task2 The second task System.Threading.Tasks.Task <T3> task3 The third task System.Threading.Tasks.Task <T4> task4 The fourth task System.Threading.Tasks.Task <T5> task5 The fifth task System.Threading.Tasks.Task <T6> task6 The sixth task System.Threading.Tasks.Task <T7> task7 The seventh task System.Threading.Tasks.Task <T8> task8 The eighth task System.Threading.Tasks.Task <T9> task9 The ninth task System.Boolean continueOnCapturedContext Indicates if the callback should be invoked on the original context or scheduler. Returns Type Description System.Threading.Tasks.Task < System.ValueTuple <T1, T2, T3, T4, T5, T6, T7, System.ValueTuple <T8, T9>>> The results of all tasks when they are all completed. Type Parameters Name Description T1 The result type returned by task1 T2 The result type returned by task2 T3 The result type returned by task3 T4 The result type returned by task4 T5 The result type returned by task5 T6 The result type returned by task6 T7 The result type returned by task7 T8 The result type returned by task8 T9 The result type returned by task9"
  },
  "api/AllOverIt.Extensions.ComparableExtensions.html": {
    "href": "api/AllOverIt.Extensions.ComparableExtensions.html",
    "title": "Class ComparableExtensions | AllOverIt",
    "keywords": "Class ComparableExtensions Inheritance System.Object ComparableExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class ComparableExtensions Methods EqualTo<TType>(IComparable<TType>, TType) Declaration public static bool EqualTo<TType>(this IComparable<TType> comparable, TType other) Parameters Type Name Description System.IComparable <TType> comparable TType other Returns Type Description System.Boolean Type Parameters Name Description TType GreaterThan<TType>(IComparable<TType>, TType) Declaration public static bool GreaterThan<TType>(this IComparable<TType> comparable, TType other) Parameters Type Name Description System.IComparable <TType> comparable TType other Returns Type Description System.Boolean Type Parameters Name Description TType GreaterThanOrEqual<TType>(IComparable<TType>, TType) Declaration public static bool GreaterThanOrEqual<TType>(this IComparable<TType> comparable, TType other) Parameters Type Name Description System.IComparable <TType> comparable TType other Returns Type Description System.Boolean Type Parameters Name Description TType LessThan<TType>(IComparable<TType>, TType) Declaration public static bool LessThan<TType>(this IComparable<TType> comparable, TType other) Parameters Type Name Description System.IComparable <TType> comparable TType other Returns Type Description System.Boolean Type Parameters Name Description TType LessThanOrEqual<TType>(IComparable<TType>, TType) Declaration public static bool LessThanOrEqual<TType>(this IComparable<TType> comparable, TType other) Parameters Type Name Description System.IComparable <TType> comparable TType other Returns Type Description System.Boolean Type Parameters Name Description TType NotEqualTo<TType>(IComparable<TType>, TType) Declaration public static bool NotEqualTo<TType>(this IComparable<TType> comparable, TType other) Parameters Type Name Description System.IComparable <TType> comparable TType other Returns Type Description System.Boolean Type Parameters Name Description TType"
  },
  "api/AllOverIt.Extensions.ExpressionExtensions.html": {
    "href": "api/AllOverIt.Extensions.ExpressionExtensions.html",
    "title": "Class ExpressionExtensions | AllOverIt",
    "keywords": "Class ExpressionExtensions Inheritance System.Object ExpressionExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Extensions Assembly : AllOverIt.dll Syntax public static class ExpressionExtensions Methods GetFieldOrProperty(Expression) Gets the field or property member of a System.Linq.Expressions.MemberExpression , unwrapped from a System.Linq.Expressions.LambdaExpression if required. Declaration public static MemberInfo GetFieldOrProperty(this Expression expression) Parameters Type Name Description System.Linq.Expressions.Expression expression The expression containing the field or property member. Returns Type Description System.Reflection.MemberInfo The field or property member. GetMemberExpressions(MemberExpression) Recursively get all System.Linq.Expressions.MemberExpression expressions linked to Declaration public static IEnumerable<MemberExpression> GetMemberExpressions(this MemberExpression expression) Parameters Type Name Description System.Linq.Expressions.MemberExpression expression The expression to get all linked System.Linq.Expressions.MemberExpression expressions. Returns Type Description System.Collections.Generic.IEnumerable < System.Linq.Expressions.MemberExpression > All linked System.Linq.Expressions.MemberExpression expressions, including . GetValue(Expression) Gets the value of an expression. Supports constants ( System.Linq.Expressions.ConstantExpression ), fields and properties ( System.Linq.Expressions.MemberExpression ), method calls System.Linq.Expressions.MethodCallExpression , and other expressions that require dynamic invocation. System.Linq.Expressions.LambdaExpression expressions are also supported if its body can be evaluated. Declaration public static object GetValue(this Expression expression) Parameters Type Name Description System.Linq.Expressions.Expression expression The expression to be evaluated. Returns Type Description System.Object The value of the . UnwrapMemberExpression(Expression) Gets the as a System.Linq.Expressions.MemberExpression . Declaration public static MemberExpression UnwrapMemberExpression(this Expression expression) Parameters Type Name Description System.Linq.Expressions.Expression expression The expression to be unwrapped as a System.Linq.Expressions.MemberExpression . Returns Type Description System.Linq.Expressions.MemberExpression If is a System.Linq.Expressions.MemberExpression then the same expression is returned. If is a System.Linq.Expressions.LambdaExpression then its Body is returned if it is a System.Linq.Expressions.MemberExpression , or a System.Linq.Expressions.UnaryExpression whos Operand is a System.Linq.Expressions.MemberExpression . In all other cases, null is returned."
  },
  "api/AllOverIt.Reflection.ReflectionHelper.html": {
    "href": "api/AllOverIt.Reflection.ReflectionHelper.html",
    "title": "Class ReflectionHelper | AllOverIt",
    "keywords": "Class ReflectionHelper Inheritance System.Object ReflectionHelper Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Reflection Assembly : AllOverIt.dll Syntax public static class ReflectionHelper Methods GetMemberType(MemberInfo) Gets the property, field or method call return type associated with the . Declaration public static Type GetMemberType(MemberInfo memberInfo) Parameters Type Name Description System.Reflection.MemberInfo memberInfo The System.Reflection.MemberInfo of the property, field or method call. Returns Type Description System.Type The property, field or method call return type. GetMemberValue(MemberInfo, Object) Gets the value of a target property or field using its associated System.Reflection.MemberInfo . Declaration public static object GetMemberValue(MemberInfo memberInfo, object target) Parameters Type Name Description System.Reflection.MemberInfo memberInfo The System.Reflection.MemberInfo of the property or field being read. System.Object target The target object being read. Returns Type Description System.Object The value of the property or field referred to by . GetMethodInfo<TType>(BindingOptions, Boolean) Gets System.Reflection.MethodInfo (method metadata) for a given and binding option. Declaration public static IEnumerable<MethodInfo> GetMethodInfo<TType>(BindingOptions binding = BindingOptions.Static | BindingOptions.Instance | BindingOptions.Abstract | BindingOptions.Virtual | BindingOptions.NonVirtual | BindingOptions.Protected | BindingOptions.Public | BindingOptions.DefaultScope | BindingOptions.DefaultAccessor | BindingOptions.DefaultVisibility | BindingOptions.Default | BindingOptions.AllScope | BindingOptions.AllAccessor, bool declaredOnly = false) Parameters Type Name Description BindingOptions binding The binding option that determines the scope, access, and visibility rules to apply when searching for the metadata. System.Boolean declaredOnly If true, the metadata of properties in the declared class as well as base class(es) are returned. If false, only method metadata of the declared type is returned. Returns Type Description System.Collections.Generic.IEnumerable < System.Reflection.MethodInfo > The method metadata, as System.Reflection.MethodInfo , of a specified . Type Parameters Name Description TType The type to obtain method metadata for. Remarks When class inheritance is involved, this method returns the first method found, starting at the type represented by . GetMethodInfo<TType>(String) Gets System.Reflection.MethodInfo (method metadata) for a given method with a given name and no arguments. Declaration public static MethodInfo GetMethodInfo<TType>(string name) Parameters Type Name Description System.String name The name of the method. Returns Type Description System.Reflection.MethodInfo The method metadata, as System.Reflection.MethodInfo , of a specified with a given name and no arguments. Type Parameters Name Description TType The type to obtain method metadata for. Remarks All instance, static, public, and non-public methods are searched. GetMethodInfo<TType>(String, Type[]) Gets System.Reflection.MethodInfo (method metadata) for a given method with a given name and argument types. Declaration public static MethodInfo GetMethodInfo<TType>(string name, Type[] types) Parameters Type Name Description System.String name The name of the method. System.Type [] types The argument types expected on the method Returns Type Description System.Reflection.MethodInfo The method metadata, as System.Reflection.MethodInfo , of a specified with a given name and argument types. Type Parameters Name Description TType The type to obtain method metadata for. Remarks All instance, static, public, and non-public methods are searched. GetPropertyInfo<TType>(BindingOptions, Boolean) Gets System.Reflection.PropertyInfo (property metadata) for a given and binding option. Declaration public static IEnumerable<PropertyInfo> GetPropertyInfo<TType>(BindingOptions binding = BindingOptions.Static | BindingOptions.Instance | BindingOptions.Abstract | BindingOptions.Virtual | BindingOptions.NonVirtual | BindingOptions.Protected | BindingOptions.Public | BindingOptions.DefaultScope | BindingOptions.DefaultAccessor | BindingOptions.DefaultVisibility | BindingOptions.Default | BindingOptions.AllScope | BindingOptions.AllAccessor, bool declaredOnly = false) Parameters Type Name Description BindingOptions binding The binding option that determines the scope, access, and visibility rules to apply when searching for the metadata. System.Boolean declaredOnly If true, the metadata of properties in the declared class as well as base class(es) are returned. If false, only property metadata of the declared type is returned. Returns Type Description System.Collections.Generic.IEnumerable < System.Reflection.PropertyInfo > The property metadata, as System.Reflection.PropertyInfo , of a specified . Type Parameters Name Description TType The type to obtain property metadata for. Remarks When class inheritance is involved, this method returns the first property found, starting at the type represented by . GetPropertyInfo<TType>(String) Gets the System.Reflection.PropertyInfo (property metadata) for a given property on a . Declaration public static PropertyInfo GetPropertyInfo<TType>(string propertyName) Parameters Type Name Description System.String propertyName The name of the property to obtain metadata for. Returns Type Description System.Reflection.PropertyInfo The property metadata, as System.Reflection.PropertyInfo , of a specified property on the specified . Type Parameters Name Description TType The type to obtain the property metadata from. Remarks When class inheritance is involved, this method returns the first property found, starting at the type represented by . SetMemberValue(MemberInfo, Object, Object) Sets the value of a target property or field using its associated System.Reflection.MemberInfo . Declaration public static void SetMemberValue(MemberInfo memberInfo, object target, object value) Parameters Type Name Description System.Reflection.MemberInfo memberInfo The System.Reflection.MemberInfo of the property or field to have its value set. System.Object target The target object being updated. System.Object value The value to assign to the property or field."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "AllOverIt | AllOverIt",
    "keywords": "AllOverIt The documentation in this section has been auto-generated from comments in the source code, available from GitHub ."
  },
  "api/AllOverIt.Events.IEventAggregator.html": {
    "href": "api/AllOverIt.Events.IEventAggregator.html",
    "title": "Interface IEventAggregator | AllOverIt",
    "keywords": "Interface IEventAggregator Namespace : AllOverIt.Events Assembly : AllOverIt.dll Syntax public interface IEventAggregator Methods Publish<TMessage>(TMessage) Declaration void Publish<TMessage>(TMessage message) Parameters Type Name Description TMessage message Type Parameters Name Description TMessage PublishAsync<TMessage>(TMessage) Declaration Task PublishAsync<TMessage>(TMessage message) Parameters Type Name Description TMessage message Returns Type Description System.Threading.Tasks.Task Type Parameters Name Description TMessage Subscribe<TMessage>(Action<TMessage>, Boolean) Declaration void Subscribe<TMessage>(Action<TMessage> handler, bool weakSubscription = true) Parameters Type Name Description System.Action <TMessage> handler System.Boolean weakSubscription Type Parameters Name Description TMessage Subscribe<TMessage>(Func<TMessage, Task>, Boolean) Declaration void Subscribe<TMessage>(Func<TMessage, Task> handler, bool weakSubscription = true) Parameters Type Name Description System.Func <TMessage, System.Threading.Tasks.Task > handler System.Boolean weakSubscription Type Parameters Name Description TMessage Unsubscribe<TMessage>(Action<TMessage>) Declaration void Unsubscribe<TMessage>(Action<TMessage> handler) Parameters Type Name Description System.Action <TMessage> handler Type Parameters Name Description TMessage Unsubscribe<TMessage>(Func<TMessage, Task>) Declaration void Unsubscribe<TMessage>(Func<TMessage, Task> handler) Parameters Type Name Description System.Func <TMessage, System.Threading.Tasks.Task > handler Type Parameters Name Description TMessage Extension Methods ObjectExtensions.ToPropertyDictionary(Object, Boolean, BindingOptions) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingFlags) ObjectExtensions.GetPropertyValue<TValue>(Object, String, BindingOptions) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingFlags) ObjectExtensions.SetPropertyValue<TValue>(Object, String, TValue, BindingOptions) ObjectExtensions.IsIntegral(Object) ObjectExtensions.As<TType>(Object, TType) ObjectExtensions.AsNullable<TType>(Object, Nullable<TType>) ObjectExtensions.CalculateHashCode<TType>(TType, IEnumerable<String>, IEnumerable<String>) ObjectExtensions.CalculateHashCode<TType>(TType, Func<TType, Object>[]) Guard.WhenNotNull<TType>(TType, String)"
  },
  "api/AllOverIt.Tasks.RepeatingTask.html": {
    "href": "api/AllOverIt.Tasks.RepeatingTask.html",
    "title": "Class RepeatingTask | AllOverIt",
    "keywords": "Class RepeatingTask Inheritance System.Object RepeatingTask Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : AllOverIt.Tasks Assembly : AllOverIt.dll Syntax public static class RepeatingTask Methods Start(Action, CancellationToken, Int32, Int32) Declaration public static Task Start(Action action, CancellationToken cancellationToken, int repeatDelay, int initialDelay = 0) Parameters Type Name Description System.Action action System.Threading.CancellationToken cancellationToken System.Int32 repeatDelay System.Int32 initialDelay Returns Type Description System.Threading.Tasks.Task Start(Func<Task>, CancellationToken, Int32, Int32) Declaration public static Task Start(Func<Task> action, CancellationToken cancellationToken, int repeatDelay, int initialDelay = 0) Parameters Type Name Description System.Func < System.Threading.Tasks.Task > action System.Threading.CancellationToken cancellationToken System.Int32 repeatDelay System.Int32 initialDelay Returns Type Description System.Threading.Tasks.Task"
  },
  "library/docs/eventaggregator.html": {
    "href": "library/docs/eventaggregator.html",
    "title": "Event Aggregation | AllOverIt",
    "keywords": "Event Aggregation EventAggregator The EventAggregator acts as a messaging hub when used as a singleton. Various layers within an application can subscribe for messages published by other areas of the application; and all in a strongly-typed manner. Consider a situation where you need to pass a reference to an object around to different parts of an application that have no direct knowledge of each other. The class below represents such an object: public sealed class SiteChanged { public ISiteDetails SiteDetails { get; } public SiteChanged(ISiteDetails siteDetails) { SiteDetails = siteDetails; } } Publishing Messages can be published using the synchronous Publish() or asynchronous PublishAsync() method, like so: // currentSite is an instance of ISiteDetails // eventAggregator is an instance of EventAggregator var siteChanged = new SiteChanged(currentSite); await eventAggregator.PublishAsync(siteChanged); Subscribing Use the Subscribe() method to be notified of new messages, like so: eventAggregator.Subscribe<SiteChanged>(HandleSiteChanged); Where the HandleSiteChanged() method is declared like so: private void HandleSiteChanged(SiteChanged message) { // required implementation here } Weak subscriptions The Subscribe() method defaults to using weak references. This provides the ability for subscriptions to be automatically released if the subscriber is disposed of. If you require a strong referenced subscription, call the Subscribe() method like so: eventAggregator.Subscribe<SiteChanged>(HandleSiteChanged, false); Unsubscribing When you no longer require to be notified of messages, such as during disposal, the events can be unsubscribed used the Unsubscribe() method, like so: eventAggregator.Unsubscribe<SiteChanged>(HandleSiteChanged);"
  },
  "library/docs/tasks.html": {
    "href": "library/docs/tasks.html",
    "title": "Tasks | AllOverIt",
    "keywords": "Tasks AsyncLazy<TType> public class AsyncLazy<TType> : Lazy<Task<TType>> { public AsyncLazy(Func<TType> factory); public AsyncLazy(Func<Task<TType>> factory); public TaskAwaiter<TType> GetAwaiter(); } Provides support for lazy initialization using a factory that returns a Task<TType> . AsyncLazy can be constructed using either a Func<TType> or a Func<Task<TType>> . The GetAwaiter() method allows you to get the result by awaiting the AsyncLazy<TType> instance without the need to reference the Value property as shown in the following example: var lazyPreferences = new AsyncLazy<Preferences>(() => GetPreferences()); // ... var preferences = await lazyPreferences; RepeatingTask public static Task Start(Func<Task> action, CancellationToken cancellationToken, int repeatDelay, int initialDelay = 0); public static Task Start(Action action, CancellationToken cancellationToken, int repeatDelay, int initialDelay = 0); The RepeatingTask.Start() methods provide the ability to execute a repeating, long running, action or awaitable task in the background. Each overload provides the ability to wait for an initial period before the first invocation, followed by a repeating delay between subsequent invocations. TaskHelper WhenAll public static async Task<(T1, T2)> WhenAll<T1, T2>(Task<T1> task1, Task<T2> task2, bool continueOnCapturedContext = false); Overloads of WhenAll are available to cater for up to seven tasks. They all await for all tasks to complete and return the results as a Tuple, as shown in the following example: var (preferences, catalog) = await TaskHelper.WhenAll( GetPreferencesAsync(), GetCatalogAsync() );"
  },
  "index.html": {
    "href": "index.html",
    "title": "AllOverIt | AllOverIt",
    "keywords": "AllOverIt A general purpose .NET Standard 2.0 library containing a variety of classes, utilities, and helpers to fill in regularly occuring software development gaps. The Library section of this site provides examples of usage for some of the more core features available, while the Api Documentation section provides more specific information for each of the classes and utilities available. Quick Links Reflection with flexible binding options Reflection is a powerful tool but it can often be difficult to remember the syntax required to discover properties and methods of a class type or instance. AllOverIt provides a variety of extension and utility methods to simplify the experience. See Reflection for more details. Expressions AllOverIt includes an expression based predicate builder as well as a variety of extensions that simplify the process of obtaining property and method metadata.. See Expressions for more details. Event Aggregation AllOverIt provides the ability for disparate layers of an architecture to publish messages and subscribe to events using a strongly-typed event aggregator. See EventAggregator for more details. Extension methods AllOverIt includes a variety of extension methods to simplify working with strings, dictionaries, doubles, objects, types, tasks, amd more. See Extension Methods for more details. Tasks AllOverIt includes helper methods to await multiple tasks and have thei results returned as a Tuple, as well as an async version of Lazy<T> . See Tasks for more details. Utilities and Helpers AllOverIt also contains a number of general-purpose utilities. See Helpers for more details."
  }
}