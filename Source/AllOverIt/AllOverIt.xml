<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AllOverIt</name>
    </assembly>
    <members>
        <member name="T:AllOverIt.Assertion.Guard">
            <summary>Provides a number of extensions that enable method pre-condition checking.</summary>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.CheckNotNull``1(``0,System.String,System.String)">
            <summary>Checks the specified object is not null.</summary>
            <typeparam name="TType">The object type.</typeparam>
            <param name="object">The object instance.</param>
            <param name="name">The name of the instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null".</param>
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.CheckNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>Checks the specified enumerable is not null or empty.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="object">The enumerable instance</param>
            <param name="name">The name of the instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty collection.</param>
            <remarks>If <paramref name="object"/> is a lazily-evaluated enumerable, such as the result if a LINQ Select() then multiple
            enumeration will occur. Only pass a concrete enumerable, such as an array or list, to this method.</remarks>
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.CheckNotEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>Checks the specified enumerable is not empty.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="object">The enumerable instance.</param>
            <param name="name">The name of the instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be empty".</param>
            <remarks>If <paramref name="object"/> is a lazily-evaluated enumerable, such as the result if a LINQ Select() then multiple
            enumeration will occur. Only pass a concrete enumerable, such as an array or list, to this method.</remarks>
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.CheckNotNullOrEmpty(System.String,System.String,System.String)">
            <summary>Checks the specified string is not null or empty.</summary>
            <param name="object">The string instance</param>
            <param name="name">The name of the instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty string.</param>
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.CheckNotEmpty(System.String,System.String,System.String)">
            <summary>Checks the specified string is not empty.</summary>
            <param name="object">The string instance</param>
            <param name="name">The name of the instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be empty".</param>
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.InvalidWhenNull``1(``0,System.String)">
            <summary>Throws an exception if the object instance is null, otherwise it returns the same instance.</summary>
            <typeparam name="TType">The object type.</typeparam>
            <param name="object">The object instance.</param>
            <param name="errorMessage">The error message to throw if the instance is null. If not provided, the default message
            is "Value cannot be null".</param>
            <returns>The same source object instance.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.InvalidWhenNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Throws an exception if the specified enumerable is null or empty, otherwise it returns the same instance.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="object">The enumerable instance</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty collection.</param>
            <remarks>If <paramref name="object"/> is a lazily-evaluated enumerable, such as the result if a LINQ Select() then multiple
            enumeration will occur. Only pass a concrete enumerable, such as an array or list, to this method.</remarks>
            <exception cref="T:System.InvalidOperationException"/>
            <returns>The same source object instance.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.InvalidWhenEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Throws an exception if the specified enumerable is empty, otherwise it returns the same instance.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="object">The enumerable instance</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be empty".</param>
            <remarks>If <paramref name="object"/> is a lazily-evaluated enumerable, such as the result if a LINQ Select() then multiple
            enumeration will occur. Only pass a concrete enumerable, such as an array or list, to this method.</remarks>
            <exception cref="T:System.InvalidOperationException"/>
            <returns>The same source object instance.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.InvalidWhenNullOrEmpty(System.String,System.String)">
            <summary>Throws an exception if the specified string is null or empty, otherwise it returns the same instance.</summary>
            <param name="object">The string instance</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty string.</param>
            <exception cref="T:System.InvalidOperationException"/>
            <returns>The same source string instance.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.InvalidWhenEmpty(System.String,System.String)">
            <summary>Throws an exception if the specified string is empty, otherwise it returns the same instance.</summary>
            <param name="object">The string instance</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be empty".</param>
            <exception cref="T:System.InvalidOperationException"/>
            <returns>The same source string instance.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotNull``1(System.Linq.Expressions.Expression{System.Func{``0}},System.String)">
            <summary>Checks that the evaluated expression is not null.</summary>
            <typeparam name="TType">The expression's return type.</typeparam>
            <param name="expression">The expression to evaluate.</param>
            <param name="errorMessage">The error message to throw if the instance is null. If not provided, the default message
            is "Value cannot be null".</param>
            <returns>The value of the evaluated expression.</returns>
            <remarks>Evaluating the expression is an expensive operation as it must be compiled before it can be invoked.</remarks>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotNullOrEmpty``1(System.Linq.Expressions.Expression{System.Func{System.Collections.Generic.IEnumerable{``0}}},System.String)">
            <summary>Checks that the evaluated expression is not null and not empty.</summary>
            <typeparam name="TType">The expression's return type.</typeparam>
            <param name="expression">The expression to evaluate.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty collection.</param>
            <returns>The value of the evaluated expression.</returns>
            <remarks>Evaluating the expression is an expensive operation as it must be compiled before it can be invoked.</remarks>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotEmpty``1(System.Linq.Expressions.Expression{System.Func{System.Collections.Generic.IEnumerable{``0}}},System.String)">
            <summary>Checks that the evaluated expression is not empty.</summary>
            <typeparam name="TType">The expression's return type.</typeparam>
            <param name="expression">The expression to evaluate.</param>
            <param name="errorMessage">The error message to throw if the instance is null. If not provided, the default message
            is "Value cannot be empty".</param>
            <returns>The value of the evaluated expression. The evaluated value can be null.</returns>
            <remarks>Evaluating the expression is an expensive operation as it must be compiled before it can be invoked.</remarks>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotNullOrEmpty(System.Linq.Expressions.Expression{System.Func{System.String}},System.String)">
            <summary>Checks that the evaluated expression is not null and not empty.</summary>
            <param name="expression">The expression to evaluate.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty collection.</param>
            <returns>The value of the evaluated expression.</returns>
            <remarks>Evaluating the expression is an expensive operation as it must be compiled before it can be invoked.</remarks>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotEmpty(System.Linq.Expressions.Expression{System.Func{System.String}},System.String)">
            <summary>Checks that the evaluated expression is not empty.</summary>
            <param name="expression">The expression to evaluate.</param>
            <param name="errorMessage">The error message to throw if the instance is null. If not provided, the default message
            is "Value cannot be empty".</param>
            <returns>The value of the evaluated expression. The evaluated value can be null.</returns>
            <remarks>Evaluating the expression is an expensive operation as it must be compiled before it can be invoked.</remarks>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotNull``1(``0,System.String,System.String)">
            <summary>Checks that the provided object is not null.</summary>
            <typeparam name="TType">The object type.</typeparam>
            <param name="object">The object instance.</param>
            <param name="name">The name identifying the object instance.</param>
            <param name="errorMessage">The error message to throw if the instance is null. If not provided, the default message
            is "Value cannot be null".</param>
            <returns>The original object instance when not null.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>Checks that the provided collection is not null and not empty.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="object">The collection instance.</param>
            <param name="name">The name identifying the collection instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty collection.</param>
            <returns>The original object instance when not null and not empty.</returns>
            <remarks>This method also validates that the enumerable is an array or ICollection&lt;TType&gt; to prevent multiple enumeration of the IEnumerable.</remarks>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Boolean,System.String)">
            <summary>Checks that the provided collection is not null and not empty.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="object">The collection instance.</param>
            <param name="name">The name identifying the collection instance.</param>
            <param name="ensureIsCollection">Indicates if the method should also validate that the enumerable is an array or ICollection&lt;TType&gt;
            to prevent multiple enumeration of the IEnumerable.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty collection.</param>
            <returns>The original object instance when not null and not empty.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>Checks that the provided collection is not empty.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="object">The collection instance.</param>
            <param name="name">The name identifying the collection instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty collection.</param>
            <returns>The original collection instance when not empty. If the instance was null then null will be returned.</returns>
            <remarks>This method also validates that the enumerable is an array or ICollection&lt;TType&gt; to prevent multiple enumeration of the IEnumerable.</remarks>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Boolean,System.String)">
            <summary>Checks that the provided collection is not empty.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="object">The collection instance.</param>
            <param name="name">The name identifying the collection instance.</param>
            <param name="ensureIsCollection">Indicates if the method should also validate that the enumerable is an array or ICollection&lt;TType&gt;
            to prevent multiple enumeration of the IEnumerable.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be empty".</param>
            <returns>The original collection instance when not empty. If the instance was null then null will be returned.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotNullOrEmpty(System.String,System.String,System.String)">
            <summary>Checks that the provided string is not null and not empty.</summary>
            <param name="object">The string instance.</param>
            <param name="name">The name identifying the string instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be null" for a null
            instance and "Value cannot be empty" for an empty collection.</param>
            <returns>The original string instance when not null and not empty.</returns>
        </member>
        <member name="M:AllOverIt.Assertion.Guard.WhenNotEmpty(System.String,System.String,System.String)">
            <summary>Checks that the provided string is not empty.</summary>
            <param name="object">The string instance.</param>
            <param name="name">The name identifying the string instance.</param>
            <param name="errorMessage">The error message to report. If not provided, the default message is "Value cannot be empty".</param>
            <returns>The original string instance when not empty.</returns>
        </member>
        <member name="T:AllOverIt.Async.AsyncLazy`1">
            <summary>
            Provides support for lazy initialization using a factory that returns a Task{TType}.
            </summary>
            <typeparam name="TType">The type that is lazily initialized.</typeparam>
        </member>
        <member name="M:AllOverIt.Async.AsyncLazy`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the AsyncLazy{TType} class. When lazy initialization occurs, the specified initialization
            factory is executed asynchronously.
            </summary>
            <param name="factory">The factory used for lazy initialization of the stored value.</param>
        </member>
        <member name="M:AllOverIt.Async.AsyncLazy`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}})">
            <summary>
            Initializes a new instance of the AsyncLazy{TType} class. When lazy initialization occurs, the specified initialization
            factory is executed asynchronously.
            </summary>
            <param name="factory">The factory used for lazy initialization of the stored value.</param>
        </member>
        <member name="M:AllOverIt.Async.AsyncLazy`1.GetAwaiter">
            <summary>
            Gets an awaiter that allows for 'await lazyProp' instead of 'await lazyProp.Value'
            </summary>
            <returns>An awaiter for the value being initialized.</returns>
        </member>
        <member name="T:AllOverIt.Async.CompositeAsyncDisposable">
            <summary>A composite that caters for asynchronous disposal of multiple IAsyncDisposable's using a synchronous Dispose().</summary>
        </member>
        <member name="M:AllOverIt.Async.CompositeAsyncDisposable.#ctor(System.IAsyncDisposable[])">
            <summary>Constructor.</summary>
            <param name="disposables">Async disposables to add to the composite disposable.</param>
        </member>
        <member name="M:AllOverIt.Async.CompositeAsyncDisposable.Add(System.IAsyncDisposable[])">
            <summary>Adds async disposables to the composite disposable.</summary>
            <param name="disposables">Async disposables to add to the composite disposable.</param>
        </member>
        <member name="M:AllOverIt.Async.CompositeAsyncDisposable.Dispose">
            <summary>Disposes each of the registered disposables. This method does not return until they are all processed.</summary>
            <remarks>Dispose() will dispose of all registered IAsyncDisposable's in a background thread, whereas DisposeAsync() will
            perform the disposal on the calling thread.</remarks>
        </member>
        <member name="M:AllOverIt.Async.CompositeAsyncDisposable.DisposeAsync">
            <summary>Disposes each of the registered disposables. This method does not return until they are all processed.</summary>
            <remarks>Dispose() will dispose of all registered IAsyncDisposable's in a background thread, whereas DisposeAsync() will
            perform the disposal on the calling thread.</remarks>
        </member>
        <member name="T:AllOverIt.Async.RepeatingTask">
            <summary>Provides support for creating and executing a new task repeatedly until cancelled.</summary>
        </member>
        <member name="M:AllOverIt.Async.RepeatingTask.Start(System.Func{System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>Creates and starts a new task that repeatedly invokes an asynchronous function.</summary>
            <param name="action">The asynchronous function to execute each time the task repeats.</param>
            <param name="cancellationToken">The cancellation token used to terminate the task.</param>
            <param name="repeatDelay">The frequency (milliseconds) the task should repeat.</param>
            <param name="initialDelay">An initial delay (milliseconds) to wait before executing the first function invocation.</param>
            <returns>The started task.</returns>
        </member>
        <member name="M:AllOverIt.Async.RepeatingTask.Start(System.Action,System.Int32,System.Threading.CancellationToken,System.Int32)">
            <summary>Creates and starts a new task that repeatedly invokes a function.</summary>
            <param name="action">The function to execute each time the task repeats.</param>
            <param name="cancellationToken">The cancellation token used to terminate the task.</param>
            <param name="repeatDelay">The frequency (milliseconds) the task should repeat.</param>
            <param name="initialDelay">An initial delay (milliseconds) to wait before executing the first function invocation.</param>
            <returns>The started task.</returns>
        </member>
        <member name="T:AllOverIt.Async.TaskHelper">
            <summary>Provides a variety of extension methods for <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``3(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <typeparam name="T3">The result type returned by <paramref name="task3"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="task3">The third task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``4(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2},System.Threading.Tasks.Task{``3},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <typeparam name="T3">The result type returned by <paramref name="task3"/></typeparam>
            <typeparam name="T4">The result type returned by <paramref name="task4"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="task3">The third task</param>
            <param name="task4">The fourth task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``5(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2},System.Threading.Tasks.Task{``3},System.Threading.Tasks.Task{``4},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <typeparam name="T3">The result type returned by <paramref name="task3"/></typeparam>
            <typeparam name="T4">The result type returned by <paramref name="task4"/></typeparam>
            <typeparam name="T5">The result type returned by <paramref name="task5"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="task3">The third task</param>
            <param name="task4">The fourth task</param>
            <param name="task5">The fifth task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``6(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2},System.Threading.Tasks.Task{``3},System.Threading.Tasks.Task{``4},System.Threading.Tasks.Task{``5},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <typeparam name="T3">The result type returned by <paramref name="task3"/></typeparam>
            <typeparam name="T4">The result type returned by <paramref name="task4"/></typeparam>
            <typeparam name="T5">The result type returned by <paramref name="task5"/></typeparam>
            <typeparam name="T6">The result type returned by <paramref name="task6"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="task3">The third task</param>
            <param name="task4">The fourth task</param>
            <param name="task5">The fifth task</param>
            <param name="task6">The sixth task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``7(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2},System.Threading.Tasks.Task{``3},System.Threading.Tasks.Task{``4},System.Threading.Tasks.Task{``5},System.Threading.Tasks.Task{``6},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <typeparam name="T3">The result type returned by <paramref name="task3"/></typeparam>
            <typeparam name="T4">The result type returned by <paramref name="task4"/></typeparam>
            <typeparam name="T5">The result type returned by <paramref name="task5"/></typeparam>
            <typeparam name="T6">The result type returned by <paramref name="task6"/></typeparam>
            <typeparam name="T7">The result type returned by <paramref name="task7"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="task3">The third task</param>
            <param name="task4">The fourth task</param>
            <param name="task5">The fifth task</param>
            <param name="task6">The sixth task</param>
            <param name="task7">The seventh task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``8(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2},System.Threading.Tasks.Task{``3},System.Threading.Tasks.Task{``4},System.Threading.Tasks.Task{``5},System.Threading.Tasks.Task{``6},System.Threading.Tasks.Task{``7},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <typeparam name="T3">The result type returned by <paramref name="task3"/></typeparam>
            <typeparam name="T4">The result type returned by <paramref name="task4"/></typeparam>
            <typeparam name="T5">The result type returned by <paramref name="task5"/></typeparam>
            <typeparam name="T6">The result type returned by <paramref name="task6"/></typeparam>
            <typeparam name="T7">The result type returned by <paramref name="task7"/></typeparam>
            <typeparam name="T8">The result type returned by <paramref name="task8"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="task3">The third task</param>
            <param name="task4">The fourth task</param>
            <param name="task5">The fifth task</param>
            <param name="task6">The sixth task</param>
            <param name="task7">The seventh task</param>
            <param name="task8">The eighth task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``9(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2},System.Threading.Tasks.Task{``3},System.Threading.Tasks.Task{``4},System.Threading.Tasks.Task{``5},System.Threading.Tasks.Task{``6},System.Threading.Tasks.Task{``7},System.Threading.Tasks.Task{``8},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <typeparam name="T3">The result type returned by <paramref name="task3"/></typeparam>
            <typeparam name="T4">The result type returned by <paramref name="task4"/></typeparam>
            <typeparam name="T5">The result type returned by <paramref name="task5"/></typeparam>
            <typeparam name="T6">The result type returned by <paramref name="task6"/></typeparam>
            <typeparam name="T7">The result type returned by <paramref name="task7"/></typeparam>
            <typeparam name="T8">The result type returned by <paramref name="task8"/></typeparam>
            <typeparam name="T9">The result type returned by <paramref name="task9"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="task3">The third task</param>
            <param name="task4">The fourth task</param>
            <param name="task5">The fifth task</param>
            <param name="task6">The sixth task</param>
            <param name="task7">The seventh task</param>
            <param name="task8">The eighth task</param>
            <param name="task9">The ninth task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="M:AllOverIt.Async.TaskHelper.WhenAll``10(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Threading.Tasks.Task{``2},System.Threading.Tasks.Task{``3},System.Threading.Tasks.Task{``4},System.Threading.Tasks.Task{``5},System.Threading.Tasks.Task{``6},System.Threading.Tasks.Task{``7},System.Threading.Tasks.Task{``8},System.Threading.Tasks.Task{``9},System.Boolean)">
            <summary>
            Waits for all the tasks to complete and returns their results.
            </summary>
            <typeparam name="T1">The result type returned by <paramref name="task1"/></typeparam>
            <typeparam name="T2">The result type returned by <paramref name="task2"/></typeparam>
            <typeparam name="T3">The result type returned by <paramref name="task3"/></typeparam>
            <typeparam name="T4">The result type returned by <paramref name="task4"/></typeparam>
            <typeparam name="T5">The result type returned by <paramref name="task5"/></typeparam>
            <typeparam name="T6">The result type returned by <paramref name="task6"/></typeparam>
            <typeparam name="T7">The result type returned by <paramref name="task7"/></typeparam>
            <typeparam name="T8">The result type returned by <paramref name="task8"/></typeparam>
            <typeparam name="T9">The result type returned by <paramref name="task9"/></typeparam>
            <typeparam name="T10">The result type returned by <paramref name="task10"/></typeparam>
            <param name="task1">The first task</param>
            <param name="task2">The second task</param>
            <param name="task3">The third task</param>
            <param name="task4">The fourth task</param>
            <param name="task5">The fifth task</param>
            <param name="task6">The sixth task</param>
            <param name="task7">The seventh task</param>
            <param name="task8">The eighth task</param>
            <param name="task9">The ninth task</param>
            <param name="task10">The tenth task</param>
            <param name="continueOnCapturedContext">Indicates if the callback should be invoked on the original context or scheduler.</param>
            <returns>The results of all tasks when they are all completed.</returns>
        </member>
        <member name="T:AllOverIt.Events.EventAggregator">
            <summary>Provides support for produces to publish messages and consumers to subscribe for notification of those messages.</summary>
        </member>
        <member name="M:AllOverIt.Events.EventAggregator.Publish``1(``0)">
            <inheritdoc />
            <remarks>Cannot be used when there are registered async subscriptions for the provided message type. Use
            <see cref="M:AllOverIt.Events.EventAggregator.PublishAsync``1(``0)"/> instead.</remarks>
        </member>
        <member name="M:AllOverIt.Events.EventAggregator.PublishAsync``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Events.EventAggregator.Subscribe``1(System.Action{``0},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Events.EventAggregator.Subscribe``1(System.Func{``0,System.Threading.Tasks.Task},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Events.EventAggregator.Unsubscribe``1(System.Action{``0})">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Events.EventAggregator.Unsubscribe``1(System.Func{``0,System.Threading.Tasks.Task})">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Events.IEventAggregator">
            <summary>Represents a mechanism for produces to publish messages and consumers to subscribe for notification of those messages.</summary>
        </member>
        <member name="M:AllOverIt.Events.IEventAggregator.Publish``1(``0)">
            <summary>Publishes a message and delivers it to all subscribers.</summary>
            <typeparam name="TMessage">The message type.</typeparam>
            <param name="message">The message instance.</param>
        </member>
        <member name="M:AllOverIt.Events.IEventAggregator.PublishAsync``1(``0)">
            <summary>Asynchronously publishes a message and delivers it to all subscribers.</summary>
            <typeparam name="TMessage">The message type.</typeparam>
            <param name="message">The message instance.</param>
            <returns>A task that completes after all subscribers have handled the message.</returns>
        </member>
        <member name="M:AllOverIt.Events.IEventAggregator.Subscribe``1(System.Action{``0},System.Boolean)">
            <summary>Registers a message handler for a given message type.</summary>
            <typeparam name="TMessage">The message type.</typeparam>
            <param name="handler">The message handler for the registered message type.</param>
            <param name="weakSubscription">Indicates if the handler should be registered as a weak subscription. This is the default behaviour.</param>
        </member>
        <member name="M:AllOverIt.Events.IEventAggregator.Subscribe``1(System.Func{``0,System.Threading.Tasks.Task},System.Boolean)">
            <summary>Registers an asynchronous message handler for a given message type.</summary>
            <typeparam name="TMessage">The message type.</typeparam>
            <param name="handler">The message handler for the registered message type.</param>
            <param name="weakSubscription">Indicates if the handler should be registered as a weak subscription. This is the default behaviour.</param>
        </member>
        <member name="M:AllOverIt.Events.IEventAggregator.Unsubscribe``1(System.Action{``0})">
            <summary>Unsubscribes a previously registered message handler.</summary>
            <typeparam name="TMessage">The message type.</typeparam>
            <param name="handler">The message handler to unsubscribe.</param>
        </member>
        <member name="M:AllOverIt.Events.IEventAggregator.Unsubscribe``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>Unsubscribes a previously registered asynchronous message handler.</summary>
            <typeparam name="TMessage">The message type.</typeparam>
            <param name="handler">The message handler to unsubscribe.</param>
        </member>
        <member name="T:AllOverIt.Exceptions.CommandException">
            <summary>Represents an error that occurred while executing a command.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.CommandException.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.CommandException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:AllOverIt.Exceptions.CommandException.#ctor(System.String,System.Exception)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:AllOverIt.Exceptions.EnrichedEnumException">
            <summary>Represents an error that occurred while attempting to interpret a name or value as a <see cref="T:AllOverIt.Patterns.Enumeration.EnrichedEnum`1"/>.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.EnrichedEnumException.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.EnrichedEnumException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:AllOverIt.Exceptions.EnrichedEnumException.#ctor(System.String,System.Exception)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:AllOverIt.Exceptions.ProcessException">
            <summary>Represents an error that occurred while executing an external process.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.ProcessException.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.ProcessException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:AllOverIt.Exceptions.ProcessException.#ctor(System.String,System.Exception)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:AllOverIt.Exceptions.SelfReferenceException">
            <summary>Represents on object self-reference error.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.SelfReferenceException.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.SelfReferenceException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:AllOverIt.Exceptions.SelfReferenceException.#ctor(System.String,System.Exception)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:AllOverIt.Exceptions.ValueObjectValidationException">
            <summary>Represents a validation error that occurred while initializing a <see cref="T:AllOverIt.Patterns.ValueObject.ValueObject`2"/>.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.ValueObjectValidationException.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:AllOverIt.Exceptions.ValueObjectValidationException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:AllOverIt.Exceptions.ValueObjectValidationException.#ctor(System.String,System.Exception)">
            <summary>Constructor.</summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:AllOverIt.Exceptions.ValueObjectValidationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Expressions.ParameterRebinder">
            <summary>A helper class that replaces parameter expressions in a lambda expression with alternate parameter expressions.</summary>
        </member>
        <member name="M:AllOverIt.Expressions.ParameterRebinder.ReplaceParameters(System.Collections.Generic.IDictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>Replaces parameter expressions in a lambda expression with alternate parameter expressions in the provided mapping.</summary>
            <param name="parameterMap">Contains the mapping of parameter expressions to replace in the provided lambda expression.</param>
            <param name="expression">The lambda expression to have its parameter expressions replaced.</param>
            <returns>A new expression with the parameter expressions replaced.</returns>
        </member>
        <member name="M:AllOverIt.Expressions.ParameterRebinder.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Expressions.PredicateBuilder">
            <summary>A helper class to build expression based predicates.</summary>
        </member>
        <member name="M:AllOverIt.Expressions.PredicateBuilder.True``1">
            <summary>Returns an expression that always evaluates to true.</summary>
            <typeparam name="TType">The source type of the lambda expression.</typeparam>
            <returns>An expression that always evaluates to true.</returns>
        </member>
        <member name="M:AllOverIt.Expressions.PredicateBuilder.False``1">
            <summary>Returns an expression that always evaluates to false.</summary>
            <typeparam name="TType">The source type of the lambda expression.</typeparam>
            <returns>An expression that always evaluates to false.</returns>
        </member>
        <member name="M:AllOverIt.Expressions.PredicateBuilder.Where``1(System.Boolean)">
            <summary>Begins a chain of composed expressions that are logically OR'd or AND'd together, starting with
            a <see cref="M:AllOverIt.Expressions.PredicateBuilder.True``1"/> or <see cref="M:AllOverIt.Expressions.PredicateBuilder.False``1"/> expression.</summary>
            <typeparam name="TType">The source type of the lambda expression.</typeparam>
            <param name="initialState">The boolean value to be returned by the evaluated expression.</param>
            <returns>An expression that evaluates to the value of a provided initial state.</returns>
            <remarks>This method is normally used when there is a need to chain multiple Where clauses, starting
            with a value of false when OR'ing expressions, and true when AND'ing expressions.</remarks>
        </member>
        <member name="M:AllOverIt.Expressions.PredicateBuilder.Where``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>Begins a chain of composed expressions that are logically OR'd or AND'd together.</summary>
            <typeparam name="TType">The source type of the lambda expression.</typeparam>
            <param name="expression">The first expression in the chain.</param>
            <returns>The same expression provided.</returns>
        </member>
        <member name="M:AllOverIt.Expressions.PredicateBuilder.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>Logically OR combines two expressions.</summary>
            <typeparam name="TType">The source type of the lambda expression.</typeparam>
            <param name="leftExpression">The expression to the left of the OR operation.</param>
            <param name="rightExpression">The expression to the right of the OR operation.</param>
            <returns>An expression that combines the two expressions as an OR operation.</returns>
        </member>
        <member name="M:AllOverIt.Expressions.PredicateBuilder.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>Logically AND combines two expressions.</summary>
            <typeparam name="TType">The source type of the lambda expression.</typeparam>
            <param name="leftExpression">The expression to the left of the AND operation.</param>
            <param name="rightExpression">The expression to the right of the AND operation.</param>
            <returns>An expression that combines the two expressions as an AND operation.</returns>
        </member>
        <member name="M:AllOverIt.Expressions.PredicateBuilder.Not``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>Returns an expression that represents a bitwise complement of the provided expression.</summary>
            <typeparam name="TType">The source type of the lambda expression.</typeparam>
            <param name="expression">The source expression.</param>
            <returns>An expression that represents a bitwise complement of the provided expression.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.AsyncEnumerableExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/>.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.AsyncEnumerableExtensions.AsListAsync``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Iterates over an <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/> to create a <see cref="T:System.Collections.Generic.List`1"/>.</summary>
            <typeparam name="TType">The element type.</typeparam>
            <param name="items">The enumerable to convert to a list asynchronously.</param>
            <param name="cancellationToken">A cancellation token to cancel the processing.</param>
            <returns>An <see cref="T:System.Collections.Generic.IList`1"/> from the source items.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.AsyncEnumerableExtensions.SelectAsListAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)">
            <summary>Asynchronously projects each element into another form and returns the result as an IList{TResult}.</summary>
            <typeparam name="TSource">The source elements.</typeparam>
            <typeparam name="TResult">The projected result type.</typeparam>
            <param name="items">The source items to be projected and returned as an IList{TResult}.</param>
            <param name="selector">The transform function applied to each element.</param>
            <param name="cancellationToken">A cancellation token to cancel the processing.</param>
            <returns>The projected results as an IList{TResult}.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.AsyncEnumerableExtensions.SelectAsReadOnlyCollectionAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)">
            <summary>Asynchronously projects each element into another form and returns the result as an IReadOnlyCollection{TResult}.</summary>
            <typeparam name="TSource">The source elements.</typeparam>
            <typeparam name="TResult">The projected result type.</typeparam>
            <param name="items">The source items to be projected and returned as an IReadOnlyCollection{TResult}.</param>
            <param name="selector">The transform function applied to each element.</param>
            <param name="cancellationToken">A cancellation token to cancel the processing.</param>
            <returns>The projected results as an IReadOnlyCollection{TResult}.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.AsyncEnumerableExtensions.SelectAsReadOnlyListAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)">
            <summary>Asynchronously projects each element into another form and returns the result as an IReadOnlyList{TResult}.</summary>
            <typeparam name="TSource">The source elements.</typeparam>
            <typeparam name="TResult">The projected result type.</typeparam>
            <param name="items">The source items to be projected and returned as an IReadOnlyList{TResult}.</param>
            <param name="selector">The transform function applied to each element.</param>
            <param name="cancellationToken">A cancellation token to cancel the processing.</param>
            <returns>The projected results as an IReadOnlyList{TResult}.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.ChainOfResponsibilityExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler`2"/> types.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.ChainOfResponsibilityExtensions.Compose``2(System.Collections.Generic.IEnumerable{AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler{``0,``1}})">
            <summary>Composes a collection of <see cref="T:AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler`2"/> handlers so they are chained in the provided order.</summary>
            <typeparam name="TInput">The type of the input state provided to the handler.</typeparam>
            <typeparam name="TOutput">The type of the output state provided to the handler. This can be the same as <typeparamref name="TInput"/>.</typeparam>
            <param name="handlers">The collection of handlers to be chained together.</param>
            <returns>The first handler in the chain.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.ComparableExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.IComparable`1"/> types.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.ComparableExtensions.LessThan``1(System.IComparable{``0},``0)">
            <summary>Compares one comparable with another and returns a result indicating if it is less than the other.</summary>
            <typeparam name="TType">The value type.</typeparam>
            <param name="comparable">The left operand of the comparison.</param>
            <param name="other">The right operand of the comparison.</param>
            <returns>True if the left operand is less than the right operand.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ComparableExtensions.LessThanOrEqual``1(System.IComparable{``0},``0)">
            <summary>Compares one comparable with another and returns a result indicating if it is less than or equal to the other.</summary>
            <typeparam name="TType">The value type.</typeparam>
            <param name="comparable">The left operand of the comparison.</param>
            <param name="other">The right operand of the comparison.</param>
            <returns>True if the left operand is less than or equal to the right operand.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ComparableExtensions.GreaterThan``1(System.IComparable{``0},``0)">
            <summary>Compares one comparable with another and returns a result indicating if it is greater than the other.</summary>
            <typeparam name="TType">The value type.</typeparam>
            <param name="comparable">The left operand of the comparison.</param>
            <param name="other">The right operand of the comparison.</param>
            <returns>True if the left operand is greater than the right operand.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ComparableExtensions.GreaterThanOrEqual``1(System.IComparable{``0},``0)">
            <summary>Compares one comparable with another and returns a result indicating if it is greater than or equal to the other.</summary>
            <typeparam name="TType">The value type.</typeparam>
            <param name="comparable">The left operand of the comparison.</param>
            <param name="other">The right operand of the comparison.</param>
            <returns>True if the left operand is greater than or equal to the right operand.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ComparableExtensions.EqualTo``1(System.IComparable{``0},``0)">
            <summary>Compares one comparable with another and returns a result indicating if it is equal to the other.</summary>
            <typeparam name="TType">The value type.</typeparam>
            <param name="comparable">The left operand of the comparison.</param>
            <param name="other">The right operand of the comparison.</param>
            <returns>True if the left operand is equal to the right operand.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ComparableExtensions.NotEqualTo``1(System.IComparable{``0},``0)">
            <summary>Compares one comparable with another and returns a result indicating if it is not equal to the other.</summary>
            <typeparam name="TType">The value type.</typeparam>
            <param name="comparable">The left operand of the comparison.</param>
            <param name="other">The right operand of the comparison.</param>
            <returns>True if the left operand is not equal to the right operand.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.DictionaryExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.Collections.Generic.IDictionary`2"/>.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Gets the value based on a specified key, or the value type default if the key is not found.</summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="dictionary">The source dictionary.</param>
            <param name="key">The key value.</param>
            <param name="defaultValue">When provided, this will be returned as the default value if the key is not found in the dictionary.</param>
            <returns>The value associated with the specified key, otherwise a default value.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.DictionaryExtensions.GetOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>Gets the value based on a specified key, or sets the value via a Func when the key is not found.</summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="dictionary">The source dictionary.</param>
            <param name="key">The key value.</param>
            <param name="valueCreator">The Func that provides the value to set when the key is not found.</param>
            <returns>The value based on a specified key, or the value returned by a specified Func when the key is not found.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.DoubleExtensions">
            <summary>Provides a variety of extension methods for double values.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.DoubleExtensions.IsZero(System.Double)">
            <summary>Determines if the provided value is considered to be zero.</summary>
            <param name="value">The value to be compared.</param>
            <returns>True if the value is considered to be zero, otherwise false.</returns>
            <remarks>The value is considered to be zero if the absolute value is less than an internal value of
            Epsilon (1E-7). Use the <see cref="M:AllOverIt.Extensions.DoubleExtensions.IsZero(System.Double,System.Double)"/> overload to provide an alternative value
            of Epsilon.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.DoubleExtensions.IsZero(System.Double,System.Double)">
            <summary>Determines if the provided value is considered to be zero based on a provided value of Epsilon.</summary>
            <param name="value">The value to be compared.</param>
            <param name="epsilon">The value of Epsilon to determine if the value should be considered as zero.</param>
            <returns>True if the value is considered to be zero, otherwise false.</returns>
            <remarks>The value is considered to be zero if the absolute value is less than the provided value of
            Epsilon.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.DoubleExtensions.IsEqualTo(System.Double,System.Double)">
            <summary>Compares two double values and considers them equal if their absolute difference is less than an internal
            value of Epsilon (1E-7). Use the <see cref="M:AllOverIt.Extensions.DoubleExtensions.IsEqualTo(System.Double,System.Double)"/> overload to provide an alternative value
            of Epsilon.</summary>
            <param name="lhs">The left double value to be compared.</param>
            <param name="rhs">The right double value to be compared.</param>
            <returns>True if the values are considered to be equal, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.DoubleExtensions.IsEqualTo(System.Double,System.Double,System.Double)">
            <summary>Compares two double values and considers them equal if their absolute difference is less than the provided
            value of Epsilon.</summary>
            <param name="lhs">The left double value to be compared.</param>
            <param name="rhs">The right double value to be compared.</param>
            <param name="epsilon"></param>
            <returns>True if the values are considered to be equal, otherwise false.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.EnumerableExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns the source items as an IList.</summary>
            <typeparam name="TType">The type stored in the source collection.</typeparam>
            <param name="items">The source of items to be returned as an IList.</param>
            <returns>If the source items is already an IList. If the source is already an IList then the same reference is returned,
            otherwise a new list is created and populated before being returned.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.AsReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns the source items as an IReadOnlyList.</summary>
            <typeparam name="TType">The type stored in the source collection.</typeparam>
            <param name="items">The source of items to be returned as an IReadOnlyList.</param>
            <returns>The source items as an IReadOnlyList. If the source is already an IReadOnlyList then the same
            reference is returned, otherwise a new list is created and populated before being returned.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.AsReadOnlyCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns the source items as an IReadOnlyCollection.</summary>
            <typeparam name="TType">The type stored in the source collection.</typeparam>
            <param name="items">The source of items to be returned as an IReadOnlyCollection.</param>
            <returns>The source items as an IReadOnlyCollection. If the source is already an IReadOnlyCollection then the same
            reference is returned, otherwise a new list is created and populated before being returned.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.SelectAsList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Projects each element into another form and returns the result as an IList{TResult}.</summary>
            <typeparam name="TSource">The source elements.</typeparam>
            <typeparam name="TResult">The projected result type.</typeparam>
            <param name="items">The source items to be projected and returned as an IList{TResult}.</param>
            <param name="selector">The transform function applied to each element.</param>
            <returns>The projected results as an IList{TResult}.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.SelectAsReadOnlyCollection``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Projects each element into another form and returns the result as an IReadOnlyCollection{TResult}.</summary>
            <typeparam name="TSource">The source elements.</typeparam>
            <typeparam name="TResult">The projected result type.</typeparam>
            <param name="items">The source items to be projected and returned as an IReadOnlyCollection{TResult}.</param>
            <param name="selector">The transform function applied to each element.</param>
            <returns>The projected results as an IReadOnlyCollection{TResult}.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.SelectAsReadOnlyList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Projects each element into another form and returns the result as an IReadOnlyList{TResult}.</summary>
            <typeparam name="TSource">The source elements.</typeparam>
            <typeparam name="TResult">The projected result type.</typeparam>
            <param name="items">The source items to be projected and returned as an IReadOnlyList{TResult}.</param>
            <param name="selector">The transform function applied to each element.</param>
            <returns>The projected results as an IReadOnlyList{TResult}.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.SelectAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)">
            <summary>Asynchronously projects each item within a sequence.</summary>
            <typeparam name="TType">The type of each element to be projected.</typeparam>
            <typeparam name="TResult">The projected result type.</typeparam>
            <param name="items">The sequence of elements to be projected.</param>
            <param name="selector">The transform function to be applied to each element.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>An enumerator that provides asynchronous iteration over a sequence of elements.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.IsNullOrEmpty(System.Collections.IEnumerable)">
            <summary>
            Applicable to strings and collections, this method determines if the instance is null or empty.
            </summary>
            <param name="items">The object of interest.</param>
            <returns>True if the object is null or empty.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.Batch``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Partitions a collection into multiple batches of a maximum size. 
            </summary>
            <typeparam name="TSource">The type stored in the source collection.</typeparam>
            <param name="items">The source of items to be partitioned.</param>
            <param name="batchSize">The maximum number of items in each batch.</param>
            <returns>One or more batches containing the source items partitioned into a maximum batch size.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsTaskAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>Creates a Task for each item in a collection and invokes an asynchronous function. The number of tasks is
            partitioned based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="degreeOfParallelism">Determines the maximum number of tasks that will be created.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsTaskAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,System.Threading.Tasks.Task},``1,System.Int32,System.Threading.CancellationToken)">
            <summary>Creates a Task for each item in a collection and invokes an asynchronous function. The number of tasks is
            partitioned based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <typeparam name="TInput">The type of the additional input that will be passed to the invoked function.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="input">An additional input that will be passed to the invoked function.</param>
            <param name="degreeOfParallelism">Determines the maximum number of tasks that will be created.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsTaskAsync``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``2,System.Threading.Tasks.Task},``1,``2,System.Int32,System.Threading.CancellationToken)">
            <summary>Creates a Task for each item in a collection and invokes an asynchronous function. The number of tasks is
            partitioned based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <typeparam name="TInput1">The type of the first input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput2">The type of the second input that will be passed to the invoked function.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="input1">The first input that will be passed to the invoked function.</param>
            <param name="input2">The second input that will be passed to the invoked function.</param>
            <param name="degreeOfParallelism">Determines the maximum number of tasks that will be created.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsTaskAsync``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``2,``3,System.Threading.Tasks.Task},``1,``2,``3,System.Int32,System.Threading.CancellationToken)">
            <summary>Creates a Task for each item in a collection and invokes an asynchronous function. The number of tasks is
            partitioned based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <typeparam name="TInput1">The type of the first input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput2">The type of the second input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput3">The type of the third input that will be passed to the invoked function.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="input1">The first input that will be passed to the invoked function.</param>
            <param name="input2">The second input that will be passed to the invoked function.</param>
            <param name="input3">The third input that will be passed to the invoked function.</param>
            <param name="degreeOfParallelism">Determines the maximum number of tasks that will be created.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsTaskAsync``5(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``2,``3,``4,System.Threading.Tasks.Task},``1,``2,``3,``4,System.Int32,System.Threading.CancellationToken)">
            <summary>Creates a Task for each item in a collection and invokes an asynchronous function. The number of tasks is
            partitioned based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <typeparam name="TInput1">The type of the first input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput2">The type of the second input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput3">The type of the third input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput4">The type of the forth input that will be passed to the invoked function.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="input1">The first input that will be passed to the invoked function.</param>
            <param name="input2">The second input that will be passed to the invoked function.</param>
            <param name="input3">The third input that will be passed to the invoked function.</param>
            <param name="input4">The forth input that will be passed to the invoked function.</param>
            <param name="degreeOfParallelism">Determines the maximum number of tasks that will be created.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsParallelAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>Parallelizes the invocation of a function against a collection of items. The parallelization is partitioned
            based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="degreeOfParallelism">Determines the maximum number of parallel operations.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsParallelAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,System.Threading.Tasks.Task},``1,System.Int32,System.Threading.CancellationToken)">
            <summary>Parallelizes the invocation of a function against a collection of items. The parallelization is partitioned
            based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <typeparam name="TInput">The type of the additional input that will be passed to the invoked function.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="input">An additional input that will be passed to the invoked function.</param>
            <param name="degreeOfParallelism">Determines the maximum number of parallel operations.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsParallelAsync``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``2,System.Threading.Tasks.Task},``1,``2,System.Int32,System.Threading.CancellationToken)">
            <summary>Parallelizes the invocation of a function against a collection of items. The parallelization is partitioned
            based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <typeparam name="TInput1">The type of the first input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput2">The type of the second input that will be passed to the invoked function.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="input1">The first input that will be passed to the invoked function.</param>
            <param name="input2">The second input that will be passed to the invoked function.</param>
            <param name="degreeOfParallelism">Determines the maximum number of parallel operations.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsParallelAsync``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``2,``3,System.Threading.Tasks.Task},``1,``2,``3,System.Int32,System.Threading.CancellationToken)">
            <summary>Parallelizes the invocation of a function against a collection of items. The parallelization is partitioned
            based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <typeparam name="TInput1">The type of the first input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput2">The type of the second input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput3">The type of the third input that will be passed to the invoked function.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="input1">The first input that will be passed to the invoked function.</param>
            <param name="input2">The second input that will be passed to the invoked function.</param>
            <param name="input3">The third input that will be passed to the invoked function.</param>
            <param name="degreeOfParallelism">Determines the maximum number of parallel operations.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.ForEachAsParallelAsync``5(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``2,``3,``4,System.Threading.Tasks.Task},``1,``2,``3,``4,System.Int32,System.Threading.CancellationToken)">
            <summary>Parallelizes the invocation of a function against a collection of items. The parallelization is partitioned
            based on a provided degree of parallelism.</summary>
            <typeparam name="TType">The type of each element.</typeparam>
            <typeparam name="TInput1">The type of the first input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput2">The type of the second input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput3">The type of the third input that will be passed to the invoked function.</typeparam>
            <typeparam name="TInput4">The type of the forth input that will be passed to the invoked function.</typeparam>
            <param name="items">The collection of items to be processed.</param>
            <param name="func">The asynchronous function to be invoked.</param>
            <param name="input1">The first input that will be passed to the invoked function.</param>
            <param name="input2">The second input that will be passed to the invoked function.</param>
            <param name="input3">The third input that will be passed to the invoked function.</param>
            <param name="input4">The forth input that will be passed to the invoked function.</param>
            <param name="degreeOfParallelism">Determines the maximum number of parallel operations.</param>
            <param name="cancellationToken">A cancellation token that can cancel the processing.</param>
            <returns>A task that will complete when all items have been processed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.Where``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets all candidates that meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The candidates that meet the criteria of the provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.Any``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Determines if any candidates meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>True if any of the candidates meet the criteria of the provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.All``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Determines if all candidates meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>True if all of the candidates meet the criteria of the provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.Count``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Counts the number of candidates that meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The count of candidates that meet the criteria of a provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.First``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets the first candidate that meets the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The first candidate that meets the criteria of a provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets the first candidate that meets the criteria of a provided specification or the type's
            default if there are no matches.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The first candidate that meets the criteria of a provided specification or the type's
            default if there are no matches.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.Last``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets the last candidate that meets the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The last candidate that meets the criteria of a provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets the last candidate that meets the criteria of a provided specification or the type's
            default if there are no matches.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The last candidate that meets the criteria of a provided specification or the type's
            default if there are no matches.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets the elements from the first element of the input candidates that meets the criteria of a provided
            specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>An enumerable that contains the elements from the first element of the input candidates that meets
            the criteria of a provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.EnumerableExtensions.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets the elements from the input candidates while they meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>An enumerable that contains the elements from the input candidates while they meet the criteria of a provided
            specification.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.ExpressionExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.Linq.Expressions.Expression"/> types.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.ExpressionExtensions.GetMemberExpressions(System.Linq.Expressions.MemberExpression)">
            <summary>Recursively get all <see cref="T:System.Linq.Expressions.MemberExpression"/> expressions linked to <paramref name="expression"/>.</summary>
            <param name="expression">The expression to get all linked <see cref="T:System.Linq.Expressions.MemberExpression"/> expressions.</param>
            <returns>All linked <see cref="T:System.Linq.Expressions.MemberExpression"/> expressions, including <paramref name="expression"/>.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ExpressionExtensions.UnwrapMemberExpression(System.Linq.Expressions.Expression)">
            <summary>Gets the <paramref name="expression"/> as a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</summary>
            <param name="expression">The expression to be unwrapped as a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</param>
            <returns>
            If <paramref name="expression"/> is a <see cref="T:System.Linq.Expressions.MemberExpression"/> then the same expression is returned.
            If <paramref name="expression"/> is a <see cref="T:System.Linq.Expressions.LambdaExpression"/> then its Body is returned if it is a
            <see cref="T:System.Linq.Expressions.MemberExpression"/>, or a <see cref="T:System.Linq.Expressions.UnaryExpression"/> whos' Operand is a <see cref="T:System.Linq.Expressions.MemberExpression"/>.
            In all other cases, null is returned.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ExpressionExtensions.GetFieldOrProperty(System.Linq.Expressions.Expression)">
            <summary>
            Gets the field or property member of a <see cref="T:System.Linq.Expressions.MemberExpression"/>, unwrapped from a <see cref="T:System.Linq.Expressions.LambdaExpression"/> if required.
            </summary>
            <param name="expression">The expression containing the field or property member.</param>
            <returns>The field or property member.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ExpressionExtensions.GetValue(System.Linq.Expressions.Expression)">
            <summary>
            Gets the value of an expression. Supports constants (<see cref="T:System.Linq.Expressions.ConstantExpression"/>), fields and properties (<see cref="T:System.Linq.Expressions.MemberExpression"/>),
            method calls <see cref="T:System.Linq.Expressions.MethodCallExpression"/>, and other expressions that require dynamic invocation. <see cref="T:System.Linq.Expressions.LambdaExpression"/>
            expressions are also supported if its body can be evaluated.
            </summary>
            <param name="expression">The expression to be evaluated.</param>
            <returns>The value of the <paramref name="expression"/>.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.FileInfoExtensions">
            <summary>Contains extension methods for use with <see cref="T:System.IO.FileInfo"/> instances.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.FileInfoExtensions.GetFullName(System.IO.FileInfo)">
            <summary>Gets the fully qualified path of the directory or file.</summary>
            <param name="fileInfo">The <c>FileInfo</c> instance containing information about a file or directory.</param>
            <returns>Returns the fully qualified path of the directory or file.</returns>
            <remarks>This method returns the equivalent of <c>fileInfo.FullName</c> with the exception that if the length of the string is 260 or
            more characters the method falls back to using reflection to obtain the string rather than throw a <c>PathTooLongException</c> exception.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.FileInfoExtensions.IsDirectory(System.IO.FileInfo)">
            <summary>Determines whether the <paramref name="fileInfo"/> instance represents a directory.</summary>
            <param name="fileInfo">The <c>FileInfo</c> instance containing information about a file or directory.</param>
            <returns>Returns <c>true</c> if the <paramref name="fileInfo"/> instance represents a directory.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.LinqSpecificationExtensions">
            <summary>Provides extensions methods that simplify the composition of LINQ compatible specifications.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.LinqSpecificationExtensions.And``1(AllOverIt.Patterns.Specification.ILinqSpecification{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets an expression that composes two specifications to perform a logical AND operation.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
            <returns>An expression that composes two specifications to perform a logical AND operation.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.LinqSpecificationExtensions.AndNot``1(AllOverIt.Patterns.Specification.ILinqSpecification{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets an expression that composes two specifications to perform a logical AND operation after negating
            the result of the right operand.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
            <returns>An expression that composes two specifications to perform a logical AND operation.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.LinqSpecificationExtensions.Or``1(AllOverIt.Patterns.Specification.ILinqSpecification{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets an expression that composes two specifications to perform a logical OR operation.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
            <returns>An expression that composes two specifications to perform a logical OR operation.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.LinqSpecificationExtensions.OrNot``1(AllOverIt.Patterns.Specification.ILinqSpecification{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets an expression that composes two specifications to perform a logical OR operation after negating
            the result of the right operand.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
            <returns>An expression that composes two specifications to perform a logical OR operation.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.LinqSpecificationExtensions.Not``1(AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets an expression that negates a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="specification">The specification applied against a candidate.</param>
            <returns>An expression that negates a provided specification.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.ObjectExtensions">
            <summary>Provides a variety of extension methods for object types.</summary>
        </member>
        <member name="P:AllOverIt.Extensions.ObjectExtensions.DefaultHashCodeBindings">
            <summary>
            Specifies the binding options to use when calculating the hash code of an object when using
            <see cref="M:AllOverIt.Extensions.ObjectExtensions.CalculateHashCode``1(``0,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})"/>.
            </summary>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.ToPropertyDictionary(System.Object,System.Boolean,AllOverIt.Reflection.BindingOptions)">
            <summary>Creates a dictionary containing property names and associated values.</summary>
            <param name="instance">The object instance to obtain property names and values from.</param>
            <param name="includeNulls">If true then null value properties will be included, otherwise they will be omitted.</param>
            <param name="bindingOptions">Binding options that determine how properties are resolved.</param>
            <returns>Returns a dictionary containing property names and associated values.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.ToSerializedDictionary(System.Object,AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions)">
            <summary>Converts an object to an IDictionary{string, string} using a dot notation for nested members.</summary>
            <param name="instance">The instance to convert.</param>
            <param name="options">Options that determine how serialization of properties and their values are handled.</param>
            <returns>Returns a dictionary containing property names and associated values (as strings). Nested members are named using dot notation.</returns>
            <remarks>
            <para>Collection type properties are named using a zero-based index notation.</para>
            <para>Dictionary type properties are named using the key values where possible. If the key is a class type then the class name is used along with
            a backtick and zero-based index suffix (to provide uniqueness).</para>
            </remarks>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.GetPropertyValue``1(System.Object,System.String,System.Reflection.BindingFlags)">
            <summary>
            Uses reflection to get the value of an object's property by name.
            </summary>
            <typeparam name="TValue">The property type.</typeparam>
            <param name="instance">The object to get the property value.</param>
            <param name="propertyName">The property name.</param>
            <param name="bindingFlags">.NET binding options that determine how property names are resolved.</param>
            <returns>The value of a property by name</returns>
            <exception cref="T:System.MemberAccessException">When the property name cannot be found using the provided binding flags.</exception>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.GetPropertyValue``1(System.Object,System.String,AllOverIt.Reflection.BindingOptions)">
            <summary>
            Uses reflection to get the value of an object's property by name.
            </summary>
            <typeparam name="TValue">The property type.</typeparam>
            <param name="instance">The object to get the property value.</param>
            <param name="propertyName">The property name.</param>
            <param name="bindingOptions">Binding options that determine how property names are resolved.</param>
            <returns>The value of a property by name</returns>
            <exception cref="T:System.MemberAccessException">When the property name cannot be found using the provided binding options.</exception>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.SetPropertyValue``1(System.Object,System.String,``0,System.Reflection.BindingFlags)">
            <summary>Uses reflection to set the value of an object's property by name.</summary>
            <typeparam name="TValue">The property type.</typeparam>
            <param name="instance">The object to get the property value.</param>
            <param name="propertyName">The property name.</param>
            <param name="value">The value to set.</param>
            <param name="bindingFlags">.NET binding options that determine how property names are resolved.</param>
            <exception cref="T:System.MemberAccessException">When the property name cannot be found using the provided binding flags.</exception>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.SetPropertyValue``1(System.Object,System.String,``0,AllOverIt.Reflection.BindingOptions)">
            <summary>
            Uses reflection to set the value of an object's property by name.
            </summary>
            <typeparam name="TValue">The property type.</typeparam>
            <param name="instance">The object to get the property value.</param>
            <param name="propertyName">The property name.</param>
            <param name="value">The value to set on the property.</param>
            <param name="bindingOptions">Binding options that determine how property names are resolved.</param>
            <exception cref="T:System.MemberAccessException">When the property name cannot be found using the provided binding options.</exception>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.IsIntegral(System.Object)">
            <summary>Determines if the specified object is an integral type (signed or unsigned).</summary>
            <param name="instance">The object instance to be compared to an integral type.</param>
            <returns>Returns <c>true</c> if the specified object is an integral type (signed or unsigned).</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.As``1(System.Object,``0)">
            <summary>Converts the provided source <paramref name="instance"/> to a specified type.</summary>
            <typeparam name="TType">The type that <paramref name="instance"/> is to be converted to.</typeparam>
            <param name="instance">The object instance to be converted.</param>
            <param name="defaultValue">The default value to be returned when <paramref name="instance"/> is null.</param>
            <returns>Returns <paramref name="instance"/> converted to the specified <typeparamref name="TType"/>.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.AsNullable``1(System.Object,System.Nullable{``0})">
            <summary>Converts the provided source <paramref name="instance"/> to a specified nullable type.</summary>
            <typeparam name="TType">The (nullable) type that <paramref name="instance"/> is to be converted to.</typeparam>
            <param name="instance">The object instance to be converted.</param>
            <param name="defaultValue">The default value to be returned when <paramref name="instance"/> is null.</param>
            <returns>Returns <paramref name="instance"/> converted to the specified <typeparamref name="TType"/>.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.CalculateHashCode``1(``0,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Uses reflection to find all instance properties and use them to calculate a hash code.
            </summary>
            <typeparam name="TType">The object type.</typeparam>
            <param name="instance">The instance having its hash code calculated.</param>
            <param name="includeProperties">The property names to include. If null, then all non-static properties are used.</param>
            <param name="excludeProperties">The property names to exclude. If null, then no properties are excluded.</param>
            <returns>The calculated hash code.</returns>
            <remarks>To ensure idempotency, the properties are ordered by their name before calculating the hash.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.ObjectExtensions.CalculateHashCode``1(``0,System.Func{``0,System.Object}[])">
            <summary>Calculates the hash code based on explicitly specified properties, fields, or the return result from a method call.</summary>
            <typeparam name="TType">The object type.</typeparam>
            <param name="instance">The instance having its hash code calculated.</param>
            <param name="resolvers">One or more resolvers that provide the properties, fields, or method calls used to calculate the hash code.</param>
            <returns>The calculated hash code.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.PropertyInfoExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.Reflection.PropertyInfo"/> types.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.PropertyInfoExtensions.IsAbstract(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the provided <paramref name="propertyInfo"/> is for an abstract property.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> for a property.</param>
            <returns>True if the <paramref name="propertyInfo"/> is for an abstract property, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.PropertyInfoExtensions.IsInternal(System.Reflection.PropertyInfo)">
            <summary>
            Determines of the <paramref name="propertyInfo"/> is for an internal property.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> for a property.</param>
            <returns>True if the <paramref name="propertyInfo"/> is for an internal property, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.PropertyInfoExtensions.IsPrivate(System.Reflection.PropertyInfo)">
            <summary>
            Determines of the <paramref name="propertyInfo"/> is for a private property.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> for a property.</param>
            <returns>True if the <paramref name="propertyInfo"/> is for a virtual property, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.PropertyInfoExtensions.IsProtected(System.Reflection.PropertyInfo)">
            <summary>
            Determines of the <paramref name="propertyInfo"/> is for a protected property.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> for a property.</param>
            <returns>True if the <paramref name="propertyInfo"/> is for a protected property, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.PropertyInfoExtensions.IsPublic(System.Reflection.PropertyInfo)">
            <summary>
            Determines of the <paramref name="propertyInfo"/> is for a public property.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> for a property.</param>
            <returns>True if the <paramref name="propertyInfo"/> is for a public property, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.PropertyInfoExtensions.IsStatic(System.Reflection.PropertyInfo)">
            <summary>
            Determines of the <paramref name="propertyInfo"/> is for a static property.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> for a property.</param>
            <returns>True if the <paramref name="propertyInfo"/> is for a static property, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.PropertyInfoExtensions.IsVirtual(System.Reflection.PropertyInfo)">
            <summary>
            Determines of the <paramref name="propertyInfo"/> is for a virtual property.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> for a property.</param>
            <returns>True if the <paramref name="propertyInfo"/> is for a virtual property, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.PropertyInfoExtensions.IsIndexer(System.Reflection.PropertyInfo)">
            <summary>
            Determines if a property is an indexer.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> for a property.</param>
            <returns>True if the property is an indexer.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.QueryableExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.Linq.IQueryable`1"/>.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.Where``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets all candidates that meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The candidates that meet the criteria of the provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.Any``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Determines if any candidates meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>True if any of the candidates meet the criteria of the provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.All``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Determines if all candidates meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>True if all of the candidates meet the criteria of the provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.Count``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Counts the number of candidates that meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The count of candidates that meet the criteria of a provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.First``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets the first candidate that meets the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The first candidate that meets the criteria of a provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.FirstOrDefault``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets the first candidate that meets the criteria of a provided specification or the type's
            default if there are no matches.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The first candidate that meets the criteria of a provided specification or the type's
            default if there are no matches.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.Last``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets the last candidate that meets the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The last candidate that meets the criteria of a provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.LastOrDefault``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets the last candidate that meets the criteria of a provided specification or the type's
            default if there are no matches.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>The last candidate that meets the criteria of a provided specification or the type's
            default if there are no matches.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.SkipWhile``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets the elements from the first element of the input candidates that meets the criteria of a provided
            specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>An enumerable that contains the elements from the first element of the input candidates that meets
            the criteria of a provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.QueryableExtensions.TakeWhile``1(System.Linq.IQueryable{``0},AllOverIt.Patterns.Specification.ILinqSpecification{``0})">
            <summary>Gets the elements from the input candidates while they meet the criteria of a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="candidates">The elements to apply the specification against.</param>
            <param name="specification">The specification to apply against a collection of elements.</param>
            <returns>An enumerable that contains the elements from the input candidates while they meet the criteria of a provided
            specification.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.ReadWriteLockExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:AllOverIt.Threading.IReadWriteLock"/> types.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.ReadWriteLockExtensions.GetReadLock(AllOverIt.Threading.IReadWriteLock,System.Boolean)">
            <summary>Gets a read lock that will auto-release when disposed.</summary>
            <param name="lock">The lock to obtain a read lock.</param>
            <param name="upgradeable">Indicates if the read lock can be upgraded to a write lock.</param>
            <returns>A disposable that will release the lock when disposed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.ReadWriteLockExtensions.GetWriteLock(AllOverIt.Threading.IReadWriteLock)">
            <summary>Gets a write lock that will auto-release when disposed.</summary>
            <param name="lock">The lock to obtain a write lock.</param>
            <returns>A disposable that will release the lock when disposed.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.SpecificationExtensions">
            <summary>Provides extensions methods that simplify the composition of specifications.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.SpecificationExtensions.And``1(AllOverIt.Patterns.Specification.ISpecification{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets an expression that composes two specifications to perform a logical AND operation.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
            <returns>An expression that composes two specifications to perform a logical AND operation.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.SpecificationExtensions.AndNot``1(AllOverIt.Patterns.Specification.ISpecification{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets an expression that composes two specifications to perform a logical AND operation after negating
            the result of the right operand.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
            <returns>An expression that composes two specifications to perform a logical AND operation.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.SpecificationExtensions.Or``1(AllOverIt.Patterns.Specification.ISpecification{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets an expression that composes two specifications to perform a logical OR operation.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
            <returns>An expression that composes two specifications to perform a logical OR operation.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.SpecificationExtensions.OrNot``1(AllOverIt.Patterns.Specification.ISpecification{``0},AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets an expression that composes two specifications to perform a logical OR operation after negating
            the result of the right operand.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
            <returns>An expression that composes two specifications to perform a logical OR operation.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.SpecificationExtensions.Not``1(AllOverIt.Patterns.Specification.ISpecification{``0})">
            <summary>Gets an expression that negates a provided specification.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
            <param name="specification">The specification applied against a candidate.</param>
            <returns>An expression that negates a provided specification.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.StringExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.String"/> types.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.StringExtensions.ContainsChar(System.String,System.Char)">
            <summary>Determines if a string contains a specified character.</summary>
            <param name="str">The string to be tested.</param>
            <param name="value">The character value to be searched for within the string.</param>
            <returns>True if the string contains the specified character, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.StringExtensions.As``1(System.String,``0)">
            <summary>Converts a given string to another type.</summary>
            <typeparam name="TType">The type to convert to.</typeparam>
            <param name="value">The value to be converted.</param>
            <param name="defaultValue">The value to return if <paramref name="value"/> is null, empty or contains whitespace, or is considered
            invalid for the <typeparamref name="TType"/> converter.</param>
            <returns>The converted value, or the <paramref name="defaultValue"/> value if the conversion cannot be performed.</returns>
            <remarks>
              <para>Supported conversions include byte, sbyte, decimal, double, float, int, uint, long, ulong, short, ushort, string, bool and enum.</para>
              <para>Char and Boolean type conversions must be performed using the <see cref="M:AllOverIt.Extensions.ObjectExtensions.As``1(System.Object,``0)"/> method.</para>
              <para>No attempt is made to avoid overflow or argument exceptions.</para>
            </remarks>
        </member>
        <member name="M:AllOverIt.Extensions.StringExtensions.AsNullable``1(System.String)">
            <summary>Converts a given string to another nullable type.</summary>
            <typeparam name="TType">The nullable type to convert to.</typeparam>
            <param name="value">The value to be converted.</param>
            <returns>The converted value, or null if the conversion cannot be performed.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.StringExtensions.IsNullOrEmpty(System.String)">
            <summary>Determines if a string is null, empty, or contains whitespace.</summary>
            <param name="value">The string value to compare.</param>
            <returns>True if the string is null, empty, or contains whitespace, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.StringExtensions.ToBase64(System.String)">
            <summary>Encodes a string value using base-64 digits.</summary>
            <param name="value">The value to convert to its string representation using base-64 digits.</param>
            <returns>A string encoded using base-64 digits that represents the source value.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.StringExtensions.FromBase64(System.String)">
            <summary>Decodes a string previously encoded with base-64 digits.</summary>
            <param name="value">The base-64 representation of a string to convert.</param>
            <returns>The string decoded from a source string previously encoded with base-64 digits.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.StringFormatExtensions">
            <summary>Provides extensions for formatting strings in a known format.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.StringFormatExtensions.FormatJsonString(System.String,System.Int32)">
            <summary>Returns a beautified version of the provided string, assumed to be in a JSON format.</summary>
            <param name="jsonValue">The string to be beautified.</param>
            <param name="indentSize">The number of spaces to use for indentation.</param>
            <returns>A beautified version of the provided string, assumed to be in a JSON format.</returns>
            <remarks>This method does not validate the string is well-formed.</remarks>
        </member>
        <member name="T:AllOverIt.Extensions.TypeExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.Type"/> types.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.GetPropertyInfo(System.Type,System.String)">
            <summary>Gets the <see cref="T:System.Reflection.PropertyInfo"/> (property metadata) for a given public or protected property on a <see cref="T:System.Type"/>.</summary>
            <param name="type">The <see cref="T:System.Type"/> to obtain the property metadata from.</param>
            <param name="propertyName">The name of the property to obtain metadata for.</param>
            <returns>The property metadata, as <see cref="T:System.Reflection.PropertyInfo"/>, of a specified property on the provided <paramref name="type"/>.</returns>
            <remarks>When class inheritance is involved, this method returns the first property found, starting at the type represented
            by <paramref name="type"/>.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.GetPropertyInfo(System.Type,AllOverIt.Reflection.BindingOptions,System.Boolean)">
            <summary>Gets <see cref="T:System.Reflection.PropertyInfo"/> (property metadata) for all properties on a given <see cref="T:System.Type"/> satisfying a given binding option.</summary>
            <param name="type">The type to obtain property metadata for.</param>
            <param name="binding">The binding option that determines the scope, access, and visibility rules to apply when searching for the metadata.</param>
            <param name="declaredOnly">If true, the metadata of properties in the declared class as well as base class(es) are returned.
            If false, only property metadata of the declared type is returned.</param>
            <returns>The property metadata, as <see cref="T:System.Reflection.PropertyInfo"/>, of a provided <see cref="T:System.Type"/>.</returns>
            <remarks>When class inheritance is involved, this method returns the first property found, starting at the type represented
            by <paramref name="type"/>.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.GetMethodInfo(System.Type,AllOverIt.Reflection.BindingOptions,System.Boolean)">
            <summary>Gets <see cref="T:System.Reflection.MethodInfo"/> (method metadata) for a given <see cref="T:System.Type"/> and binding option.</summary>
            <param name="type">The type to obtain method metadata for.</param>
            <param name="binding">The binding option that determines the scope, access, and visibility rules to apply when searching for the metadata.</param>
            <param name="declaredOnly">If true, the metadata of properties in the declared class as well as base class(es) are returned.
            If false, only method metadata of the declared type is returned.</param>
            <returns>The method metadata, as <see cref="T:System.Reflection.MethodInfo"/>, of a provided <see cref="T:System.Type"/>.</returns>
            <remarks>When class inheritance is involved, this method returns the first method found, starting at the type represented
            by <paramref name="type"/>.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.GetMethodInfo(System.Type,System.String)">
            <summary>Gets <see cref="T:System.Reflection.MethodInfo"/> (method metadata) for a given <see cref="T:System.Type"/> method with a given name and no arguments.</summary>
            <param name="type">The type to obtain method metadata for.</param>
            <param name="name">The name of the method.</param>
            <returns>The method metadata, as <see cref="T:System.Reflection.MethodInfo"/>, of a provided <see cref="T:System.Type"/> with a given name and no arguments.</returns>
            <remarks>All instance, static, public, and non-public methods are searched.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.GetMethodInfo(System.Type,System.String,System.Type[])">
            <summary>Gets <see cref="T:System.Reflection.MethodInfo"/> (method metadata) for a given <see cref="T:System.Type"/> method with a given name and argument types.</summary>
            <param name="type">The type to obtain method metadata for.</param>
            <param name="name">The name of the method.</param>
            <param name="types">The argument types expected on the method</param>
            <returns>The method metadata, as <see cref="T:System.Reflection.MethodInfo"/>, of a provided <see cref="T:System.Type"/> with a given name and argument types.</returns>
            <remarks>All instance, static, public, and non-public methods are searched.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsEnumType(System.Type)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents an enumeration type.</summary>
            <param name="type">The type to compare.</param>
            <returns>True if the <see cref="T:System.Type"/> represents an enumeration type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsClassType(System.Type)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents a class type.</summary>
            <param name="type">The type to compare.</param>
            <returns>True if the <see cref="T:System.Type"/> represents a class type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsPrimitiveType(System.Type)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents a primitive type.</summary>
            <param name="type">The type to compare.</param>
            <returns>True if the <see cref="T:System.Type"/> represents a primitive type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsIntegralType(System.Type)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents an integral type.</summary>
            <param name="type">The type to compare.</param>
            <returns>True if the <see cref="T:System.Type"/> represents an integral type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsFloatingType(System.Type)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents a floating type.</summary>
            <param name="type">The type to compare.</param>
            <returns>True if the <see cref="T:System.Type"/> represents a floating type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsEnumerableType(System.Type,System.Boolean)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents an enumerable type.</summary>
            <param name="type">The type to compare.</param>
            <param name="includeString">Indicates if a string type should be considered as an enumerable (of char).</param>
            <returns>True if the <see cref="T:System.Type"/> represents an enumerable type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsGenericEnumerableType(System.Type)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents a generic enumerable type.</summary>
            <param name="type">The type to compare.</param>
            <returns>True if the <see cref="T:System.Type"/> represents a generic enumerable type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsGenericType(System.Type)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents a generic type.</summary>
            <param name="type">The type to compare.</param>
            <returns>True if the <see cref="T:System.Type"/> represents a generic type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.GetGenericArguments(System.Type)">
            <summary>Gets an array of the generic type arguments for this type.</summary>
            <param name="type">The <see cref="T:System.Type"/> containing the generic type arguments.</param>
            <returns>An array of the generic type arguments for this type.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsDerivedFrom(System.Type,System.Type)">
            <summary>Determines if a type (or interface) inherits from another type (or interface).</summary>
            <param name="type">The type to be tested.</param>
            <param name="fromType">The generic type, such as typeof(List&lt;T&gt;).</param>
            <returns>True if <paramref name="type"/> inherits from <paramref name="fromType"/>, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.IsGenericNullableType(System.Type)">
            <summary>Indicates if the <see cref="T:System.Type"/> represents a generic nullable type.</summary>
            <param name="type">The type to compare.</param>
            <returns>True if the <see cref="T:System.Type"/> represents a generic nullable type, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Extensions.TypeExtensions.GetFriendlyName(System.Type)">
            <summary>A utility method that returns a print-friendly name for a given type.</summary>
            <param name="type">The type to generate a print-friendly name for.</param>
            <returns>A print-friendly name for a given type.</returns>
        </member>
        <member name="T:AllOverIt.Extensions.TypeInfoExtensions">
            <summary>Provides a variety of extension methods for <see cref="T:System.Reflection.TypeInfo"/> types.</summary>
        </member>
        <member name="M:AllOverIt.Extensions.TypeInfoExtensions.GetPropertyInfo(System.Reflection.TypeInfo,System.Boolean)">
            <summary>
            Gets all <see cref="T:System.Reflection.PropertyInfo"/> (property metadata) for a given <see cref="T:System.Reflection.TypeInfo"/>.
            </summary>
            <param name="typeInfo">The <see cref="T:System.Reflection.TypeInfo"/> to obtain all property metadata.</param>
            <param name="declaredOnly">If true, the metadata of properties in the declared class as well as base class(es) are returned
            (if a property is overriden then only the base class <see cref="T:System.Reflection.PropertyInfo"/> is returned).
            If false, only property metadata of the declared type is returned.</param>
            <returns>The property metadata, as <see cref="T:System.Reflection.PropertyInfo"/>, of a provided <see cref="T:System.Reflection.TypeInfo"/>.</returns>
            <remarks>When class inheritance is involved, this method returns the first property found, starting at the type represented
            by <paramref name="typeInfo"/>.</remarks>
        </member>
        <member name="M:AllOverIt.Extensions.TypeInfoExtensions.GetPropertyInfo(System.Reflection.TypeInfo,System.String)">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> (property metadata) for a given public or protected property on a <see cref="T:System.Reflection.TypeInfo"/>.
            </summary>
            <param name="typeInfo">The <see cref="T:System.Reflection.TypeInfo"/> to obtain the property metadata from.</param>
            <param name="propertyName">The name of the property to obtain metadata for.</param>
            <returns>The property metadata, as <see cref="T:System.Reflection.PropertyInfo"/>, of a specified property on the provided <paramref name="typeInfo"/>.</returns>
            <remarks>When class inheritance is involved, this method returns the first property found, starting at the type represented
            by <paramref name="typeInfo"/>. If the property is overriden, this means the base class <see cref="T:System.Reflection.PropertyInfo"/> will not be
            returned. If you require the base class <see cref="T:System.Reflection.PropertyInfo"/> then use the <see cref="M:AllOverIt.Extensions.TypeInfoExtensions.GetPropertyInfo(System.Reflection.TypeInfo,System.Boolean)"/>
            method.</remarks>
        </member>
        <member name="M:AllOverIt.Formatters.JsonString.Format(System.String,System.Int32)">
            <summary>Formats a well-formed JSON string.</summary>
            <param name="jsonValue">The JSON string to format.</param>
            <param name="indentSize">The indent size. The default is 2 spaces.</param>
            <returns>The formatted string. The input string is expected to be well-formed so an invalid
            input will result in an invalid formatted output.</returns>
        </member>
        <member name="T:AllOverIt.Formatters.Objects.IFormattableObjectPropertyFilter">
            <summary>Represents the ability to format values serialized by the <see cref="T:AllOverIt.Formatters.Objects.ObjectPropertySerializer"/>.</summary>
        </member>
        <member name="M:AllOverIt.Formatters.Objects.IFormattableObjectPropertyFilter.OnFormatValue(System.String)">
            <summary>Provides the ability to format a value generated by the <see cref="T:AllOverIt.Formatters.Objects.ObjectPropertySerializer"/>.</summary>
            <param name="value">The value that can be formatted.</param>
            <returns>The replacement, formatted, value to be serialized.</returns>
        </member>
        <member name="T:AllOverIt.Formatters.Objects.ObjectPropertyFilter">
            <summary>A base class that provides support for filtering properties and values when serializing via
            <see cref="T:AllOverIt.Formatters.Objects.ObjectPropertySerializer"/>.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertyFilter.Type">
            <summary>The type of the current value.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertyFilter.Path">
            <summary>The full path within the object graph where the current value sits.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertyFilter.Name">
            <summary>The name of the property associated with the current value. This will be null for values within a collection.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertyFilter.Index">
            <summary>If the current value is within a collection then this represents its relative index.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertyFilter.Parents">
            <summary>Provides a collection of parent objects associated with the current value.</summary>
        </member>
        <member name="M:AllOverIt.Formatters.Objects.ObjectPropertyFilter.OnIncludeProperty">
            <summary>Use this method to filter out properties. Return true to include the property and false to have it excluded.</summary>
        </member>
        <member name="M:AllOverIt.Formatters.Objects.ObjectPropertyFilter.OnIncludeValue">
            <summary>Use this method to filter out property values. Return true to include the value and false to have it excluded.</summary>
        </member>
        <member name="T:AllOverIt.Formatters.Objects.ObjectPropertyParent">
            <summary>Contains serialization information for the parent of an object property.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertyParent.Name">
            <summary>The name of the property. Will be null when a collection item.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertyParent.Value">
            <summary>The value of the property.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertyParent.Index">
            <summary>When an element within a collection, this is the index of the item.</summary>
        </member>
        <member name="M:AllOverIt.Formatters.Objects.ObjectPropertyParent.#ctor(System.String,System.Object,System.Nullable{System.Int32})">
            <summary>Constructor.</summary>
            <param name="name">The name of the property.</param>
            <param name="value">The value of the property.</param>
            <param name="index">When an element within a collection, this is the index of the item.</param>
        </member>
        <member name="T:AllOverIt.Formatters.Objects.ObjectPropertySerializer">
            <summary>Converts an object to an IDictionary{string, string} using a dot notation for nested members.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertySerializer.Options">
            <summary>Provides options that determine how serialization of properties and their values are handled.</summary>
        </member>
        <member name="M:AllOverIt.Formatters.Objects.ObjectPropertySerializer.#ctor(AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions)">
            <summary>Constructor.</summary>
            <param name="options">Specifies options that determine how serialization of properties and their values are handled.
            If null, a default set of options will be used.</param>
        </member>
        <member name="M:AllOverIt.Formatters.Objects.ObjectPropertySerializer.SerializeToDictionary(System.Object)">
            <summary>Serializes an object to an IDictionary{string, string}.</summary>
            <param name="instance">The object to be serialized.</param>
            <returns>A flat IDictionary{string, string} of all properties using a dot notation for nested members.</returns>
        </member>
        <member name="T:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions">
            <summary>Provides options that determine how serialization of properties and their values are handled by <see cref="T:AllOverIt.Formatters.Objects.ObjectPropertySerializer"/>.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.IgnoredTypes">
            <summary>Includes types that will be explicitly excluded during serialization.</summary>
            <remarks>Excludes {Task} and {Task&lt;&gt;} by default.</remarks>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.IncludeNulls">
            <summary>If true then null value properties will be included, otherwise they will be omitted.</summary>
            <remarks>This takes priority over custom filters via the <see cref="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.Filter"/> option.</remarks>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.IncludeEmptyCollections">
            <summary>If true then empty collection properties will be included, otherwise they will be omitted.</summary>
            <remarks>This takes priority over custom filters via the <see cref="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.Filter"/> option.</remarks>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.BindingOptions">
            <summary>Binding options that determine how properties are resolved.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.NullValueOutput">
            <summary>Specifies an alternative output for null values.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.EmptyValueOutput">
            <summary>Specifies an alternative output for empty string and collection values.</summary>
        </member>
        <member name="P:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.Filter">
            <summary>An optional filter that can be implemented to exclude properties by name or value. Values can also be modified.</summary>
        </member>
        <member name="M:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.ClearIgnoredTypes">
            <summary>Clears the current list of ignored types.</summary>
        </member>
        <member name="M:AllOverIt.Formatters.Objects.ObjectPropertySerializerOptions.AddIgnoredTypes(System.Type[])">
            <summary>Appends one or more types to be ignored.</summary>
            <param name="types">The array of types to be ignored.</param>
        </member>
        <member name="T:AllOverIt.Helpers.EnumHelper">
            <summary>Provides static, general purpose, methods related to using Enums.</summary>
        </member>
        <member name="M:AllOverIt.Helpers.EnumHelper.GetEnumValues``1">
            <summary>Returns all possible enum values.</summary>
            <typeparam name="TType">The Enum type.</typeparam>
            <returns>All possible enum values.</returns>
        </member>
        <member name="T:AllOverIt.Helpers.ExceptionAggregator">
            <summary>Collects exceptions that can be thrown as an AggregateException.</summary>
        </member>
        <member name="P:AllOverIt.Helpers.ExceptionAggregator.Exceptions">
            <summary>Provides all exceptions currently added to the aggregator.</summary>
        </member>
        <member name="M:AllOverIt.Helpers.ExceptionAggregator.AddException(System.Exception)">
            <summary>Adds a new exception to the aggregator. If it is an AggregateException it will be flattened into
            the resulting AggregateException thrown at the time of calling <see cref="M:AllOverIt.Helpers.ExceptionAggregator.ThrowIfAnyExceptions"/>.</summary>
            <param name="exception">The exception to add to the aggregator.</param>
        </member>
        <member name="M:AllOverIt.Helpers.ExceptionAggregator.ThrowIfAnyExceptions">
            <summary>Throws an AggregateException if any exceptions were added to the aggregator. If any of the exceptions
            are an AggregateException they will be flattened into the resulting AggregateException thrown.</summary>
        </member>
        <member name="T:AllOverIt.Io.DirectorySearch">
            <summary>Contains search related operations for directories that support cancellation.</summary>
        </member>
        <member name="M:AllOverIt.Io.DirectorySearch.GetDirectories(System.String,AllOverIt.Io.DiskSearchOptions)">
            <summary>Gets an enumerable collection of directories in the current directory.</summary>
            <param name="path">The relative or absolute path of the directory to search.</param>
            <param name="searchOptions">Specifies options for the search operation.</param>
            <returns>Returns an enumerable collection of directories.</returns>
        </member>
        <member name="M:AllOverIt.Io.DirectorySearch.GetDirectories(System.String,AllOverIt.Io.DiskSearchOptions,System.Threading.CancellationToken)">
            <summary>Gets an enumerable collection of directories in the current directory. Enumeration
            can be interrupted by cancelling the provided <c>CancellationToken</c>.</summary>
            <param name="path">The relative or absolute path of the directory to search.</param>
            <param name="searchOptions">Specifies options for the search operation.</param>
            <param name="cancellationToken">The cancellation token to signal when enumeration needs to be prematurely completed.</param>
            <returns>Returns an enumerable collection of directories. The enumeration may not be complete if the <c>cancellationToken</c>
            is cancelled.</returns>
        </member>
        <member name="T:AllOverIt.Io.DiskSearchOptions">
            <summary>Contains options that can be applied when performing a directory or file search.</summary>
        </member>
        <member name="F:AllOverIt.Io.DiskSearchOptions.None">
            <summary>Indicates no special handling is to be applied.</summary>
        </member>
        <member name="F:AllOverIt.Io.DiskSearchOptions.IncludeSubDirectories">
            <summary>Indicates if the search will include sub-folders.</summary>
        </member>
        <member name="F:AllOverIt.Io.DiskSearchOptions.IgnoreUnauthorizedException">
            <summary>Indicates if unauthorized exceptions are to be suppressed.</summary>
        </member>
        <member name="F:AllOverIt.Io.DiskSearchOptions.IgnoreIoException">
            <summary>Indicates if general IO Exceptions (such as file in use) are to be suppressed.</summary>
        </member>
        <member name="T:AllOverIt.Io.FileSearch">
            <summary>Contains search related operations for files that support cancellation.</summary>
        </member>
        <member name="M:AllOverIt.Io.FileSearch.GetFiles(System.String,System.String,AllOverIt.Io.DiskSearchOptions)">
            <summary>Gets an enumerable collection of files matching a file specification in the current directory.</summary>
            <param name="path">The relative or absolute path of the directory to search.</param>
            <param name="filter">The file specification to filter the returned results.</param>
            <param name="searchOptions">Specifies options for the search operation.</param>
            <returns>Returns an enumerable collection of files.</returns>
        </member>
        <member name="M:AllOverIt.Io.FileSearch.GetFiles(System.String,System.String,AllOverIt.Io.DiskSearchOptions,System.Threading.CancellationToken)">
            <summary>Gets an enumerable collection of files matching a file specification in the current directory. Enumeration
            can be interrupted by cancelling the provided <c>CancellationToken</c>.</summary>
            <param name="path">The relative or absolute path of the directory to search.</param>
            <param name="filter">The file specification to filter the returned results.</param>
            <param name="searchOptions">Specifies options for the search operation.</param>
            <param name="cancellationToken">The cancellation token to signal when enumeration needs to be prematurely completed.</param>
            <returns>Returns an enumerable collection of files. The enumeration may not be complete if the <c>cancellationToken</c>
            is cancelled.</returns>
        </member>
        <member name="T:AllOverIt.Io.FileUtils">
            <summary>Contains file and path related utilities.</summary>
        </member>
        <member name="M:AllOverIt.Io.FileUtils.CreateUniqueFilename(System.String)">
            <summary>Ensures a filename is unique by generating a unique filename if the specified file already exists.</summary>
            <param name="filename">The filename to check for uniqueness.</param>
            <returns>A filename that will not conflict with an existing file.</returns>
            <remarks>If the provided filename exists this method generates a new name that contains a numerical suffix (starting at 1) while
            ensuring the new filename also does not exist. This method does not create the file so applications should take extra measures to
            ensure the returned filename is still unique before using it (the file may have since been created by another process).</remarks>
        </member>
        <member name="M:AllOverIt.Io.FileUtils.PathIsSubFolder(System.String,System.String)">
            <summary>Determines if the provided child path is a subfolder of the provided parent path.</summary>
            <param name="parentPath">The parent path.</param>
            <param name="childPath">The child path.</param>
            <returns>True if the child path is an immediate subfolder of the parent path.</returns>
        </member>
        <member name="M:AllOverIt.Io.FileUtils.GetAbsolutePath(System.String,System.String)">
            <summary>Creates an absolute path from a source path and a relative path.</summary>
            <param name="sourcePath">The source path.</param>
            <param name="relativePath">The relative path to apply to the source path.</param>
            <returns>The absolute path derived from combining the source and relative paths.</returns>
        </member>
        <member name="M:AllOverIt.Io.FileUtils.GetAbsoluteFileName(System.String,System.String,System.String)">
            <summary>Gets an absolute filename after applying a relative path to the original source filename.</summary>
            <param name="sourceFileName">The original source filename (with path).</param>
            <param name="relativePath">The relative path to apply to the path portion of the source filename.</param>
            <param name="newFileName">If not null then the source filename is replaced.</param>
            <returns>The absolute filename derived from applying a relative path to the original source filename.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.ChainOfResponsibility.ChainOfResponsibilityComposer`2">
            <summary>Composes a sequence of 'Chain Of Responsibility' handlers.</summary>
            <typeparam name="TInput">The input state type.</typeparam>
            <typeparam name="TOutput">The output state type.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.ChainOfResponsibility.ChainOfResponsibilityComposer`2.#ctor(System.Collections.Generic.IEnumerable{AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler{`0,`1}})">
            <summary>Constructor.</summary>
            <param name="handlers">The collection of handlers to be composed in the order they are provided.</param>
        </member>
        <member name="M:AllOverIt.Patterns.ChainOfResponsibility.ChainOfResponsibilityComposer`2.Handle(`0)">
            <summary>Invokes each handler in turn with the provided state until the state is actioned.</summary>
            <param name="state">The input state to be processed.</param>
            <returns>The final output state of the input was processed. If the input state is not processed by one of the handlers
            then the default value for <typeparamref name="TInput" /> is returned (null if it is a reference type).</returns>
        </member>
        <member name="T:AllOverIt.Patterns.ChainOfResponsibility.ChainOfResponsibilityHandler`2">
            <summary>A base 'Chain Of Responsibility' handler.</summary>
            <typeparam name="TInput">The input state type.</typeparam>
            <typeparam name="TOutput">The output state type.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.ChainOfResponsibility.ChainOfResponsibilityHandler`2.SetNext(AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.ChainOfResponsibility.ChainOfResponsibilityHandler`2.Handle(`0)">
            <inheritdoc />
            <remarks>If the current handler cannot process the request then it should call base.Handle() to give
            the next handler in the chain an opportunity to process the request. To terminate the processing
            at the current handler do not call the base method.</remarks>
        </member>
        <member name="T:AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler`2">
            <summary>An interface that describes an implementation of the Chain Of Responsibility pattern.</summary>
            <typeparam name="TInput">The input state type.</typeparam>
            <typeparam name="TOutput">The output state type.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler`2.SetNext(AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler{`0,`1})">
            <summary>Sets the next handler in the chain.</summary>
            <param name="handler">The next handler that may choose to process a request.</param>
            <returns>The original handler to allow for a fluent syntax.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.ChainOfResponsibility.IChainOfResponsibilityHandler`2.Handle(`0)">
            <summary>Potentially handles a given request using the provided state.</summary>
            <param name="state">Contains the request and possibly other state information to potentially be processed
            by the current handler.</param>
            <returns>An output state.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Command.AsyncCommandPipeline`1">
            <summary>Implements a pipeline that allows multiple commands to be executed in turn where the output of each command
            is provided as the input to the next. The input and output are of the same type.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
        </member>
        <member name="T:AllOverIt.Patterns.Command.AsyncCommandPipeline`2">
            <summary>Implements a pipeline that allows multiple commands to be executed in turn where the output of each command
            is provided as the input to the next. The output type must be the same as, or inherit from, the input type.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
            <typeparam name="TOutput">The output type to be returned from the command.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Command.AsyncCommandPipeline`2.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Command.AsyncCommandPipeline`2.#ctor(AllOverIt.Patterns.Command.IAsyncCommand{`0,`1}[])">
            <summary>Constructor.</summary>
            <param name="commands">Commands to be appended to the pipeline.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Command.AsyncCommandPipeline`2.Append(AllOverIt.Patterns.Command.IAsyncCommand{`0,`1}[])">
            <summary>Appends the specified command to the pipeline.</summary>
            <param name="commands">One or more commands to be appended to the pipeline.</param>
            <returns>The pipeline instance, allowing for a fluent syntax.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Command.AsyncCommandPipeline`2.ExecuteAsync(`0)">
            <summary>Asynchronously processes a specified input by passing it to the first command in the pipeline and
            sequentially passing the output to the next command in the sequence.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
            <returns>The output from the last command in the pipeline sequence.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Command.CommandPipeline`1">
            <summary>Implements a pipeline that allows multiple commands to be executed in turn where the output of each command
            is provided as the input to the next. The input and output are of the same type.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
        </member>
        <member name="T:AllOverIt.Patterns.Command.CommandPipeline`2">
            <summary>Implements a pipeline that allows multiple commands to be executed in turn where the output of each command
            is provided as the input to the next. The output type must be the same as, or inherit from, the input type.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
            <typeparam name="TOutput">The output type to be returned from the command.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Command.CommandPipeline`2.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Command.CommandPipeline`2.#ctor(AllOverIt.Patterns.Command.ICommand{`0,`1}[])">
            <summary>Constructor.</summary>
            <param name="commands">Commands to be appended to the pipeline.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Command.CommandPipeline`2.Append(AllOverIt.Patterns.Command.ICommand{`0,`1}[])">
            <summary>Appends the specified command to the pipeline.</summary>
            <param name="commands">One or more commands to be appended to the pipeline.</param>
            <returns>The pipeline instance, allowing for a fluent syntax.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Command.CommandPipeline`2.Execute(`0)">
            <summary>Processes a specified input by passing it to the first command in the pipeline and sequentially passing the
            output to the next command in the sequence.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
            <returns>The output from the last command in the pipeline sequence.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Command.IAsyncCommand">
            <summary>Represents an asynchronous command with no input or output.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Command.IAsyncCommand.ExecuteAsync">
            <summary>Asynchronously executes the command.</summary>
            <returns>A task that completes when the command has executed.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Command.IAsyncCommand`1">
            <summary>Represents an asynchronous command with a specified input type and no output type.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Command.IAsyncCommand`1.ExecuteAsync(`0)">
            <summary>Asynchronously executes the command with a specified input.</summary>
            <param name="input">The input instance to be provided to the command.</param>
            <returns>A task that completes when the command has executed.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Command.IAsyncCommand`2">
            <summary>Represents an asynchronous command with a specified input and output type.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
            <typeparam name="TOutput">The output type to be returned from the command.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Command.IAsyncCommand`2.ExecuteAsync(`0)">
            <summary>Asynchronously executes the command with a specified input and returns an output.</summary>
            <param name="input">The input instance to be provided to the command.</param>
            <returns>A task, with the command output, that completes when the command has executed.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Command.ICommand">
            <summary>Represents a command with no input or output.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Command.ICommand.Execute">
            <summary>Executes the command.</summary>
        </member>
        <member name="T:AllOverIt.Patterns.Command.ICommand`1">
            <summary>Represents a command with a specified input type and no output type.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Command.ICommand`1.Execute(`0)">
            <summary>Executes the command with a specified input.</summary>
            <param name="input">The input instance to be provided to the command.</param>
        </member>
        <member name="T:AllOverIt.Patterns.Command.ICommand`2">
            <summary>Represents a command with a specified input and output type.</summary>
            <typeparam name="TInput">The input type to be provided to the command.</typeparam>
            <typeparam name="TOutput">The output type to be returned from the command.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Command.ICommand`2.Execute(`0)">
            <summary>Executes the command with a specified input and returns an output.</summary>
            <param name="input">The input instance to be provided to the command.</param>
            <returns>The output result from the command.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Enumeration.EnrichedEnum`1">
            <summary>A base class for creating an enumeration type that has a integer and string value.</summary>
            <typeparam name="TEnum">The type inheriting this class.</typeparam>
        </member>
        <member name="P:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.Value">
            <summary>The integer value of the enumeration.</summary>
        </member>
        <member name="P:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.Name">
            <summary>The name, or string value, of the enumeration.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.#ctor(System.Int32,System.String)">
            <summary>Constructor.</summary>
            <param name="value">The integer value of the enumeration.</param>
            <param name="name">The name, or string value, of the enumeration.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.ToString">
            <summary>Returns a string representation of the enumeration. This will be the name value.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.CompareTo(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.Equals(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.GetAllValues">
            <summary>Gets the integer values for all enumerations of this type.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.GetAllNames">
            <summary>Gets the string values, or names, for all enumerations of this type.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.GetAll">
            <summary>Gets all enumerations of this type.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.From(System.Int32)">
            <summary>Gets the enumeration instance that matches the provided integer value.</summary>
            <param name="value">The integer value of the enumeration instance to return.</param>
            <returns>The enumeration instance that matches the provided integer value.</returns>
            <exception cref="T:AllOverIt.Exceptions.EnrichedEnumException">If the value does not match any of the enumeration instances.</exception>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.From(System.String)">
            <summary>Gets the enumeration instance that matches the provided string value, either by name or integer value.</summary>
            <param name="value">The integer value or name of the enumeration instance to return.</param>
            <returns>The enumeration instance that matches the provided value, either by name or integer value.</returns>
            <exception cref="T:AllOverIt.Exceptions.EnrichedEnumException">If the name or integer value does not match any of the enumeration instances.</exception>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.TryFromNameOrValue(System.String,`0@)">
            <summary>Attempts to convert the provided value to an enumeration instance.</summary>
            <param name="nameOrValue">The string name, or integer value (as a string), to convert to an equivalent enumeration instance.</param>
            <param name="enumeration">The matching enumeration instance if a match is found.</param>
            <returns>True if the conversion was successful, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.op_Equality(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0},AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the enumerations are equal, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.op_Inequality(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0},AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the enumerations are not equal, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.op_GreaterThan(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0},AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the left operand is greater than the right operand, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.op_GreaterThanOrEqual(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0},AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the left operand is greater than or equal to the right operand, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.op_LessThan(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0},AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the left operand is less than the right operand, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.op_LessThanOrEqual(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0},AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the left operand is less than or equal to the right operand, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.op_Implicit(AllOverIt.Patterns.Enumeration.EnrichedEnum{`0})~System.Int32">
            <summary>Implicit operator to convert an enumeration to its integer equivalent.</summary>
            <param name="enum">The value to implicitly convert.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Enumeration.EnrichedEnum`1.op_Explicit(System.Int32)~AllOverIt.Patterns.Enumeration.EnrichedEnum{`0}">
            <summary>Explicit operator to convert an integer value to its enumeration equivalent.</summary>
            <param name="value">The value to explicitly convert.</param>
        </member>
        <member name="T:AllOverIt.Patterns.ResourceInitialization.Raii">
            <summary>A disposable object implementing the Resource Acquisition Is Initialization idiom.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.Raii.#ctor(System.Action,System.Action)">
            <summary>Constructor used to provide the initialization and cleanup actions to be invoked.</summary>
            <param name="initialize">The initialization action to invoke at the time of initialization.</param>
            <param name="cleanUp">The cleanup action to perform when the object is disposed.</param>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.Raii.Dispose">
            <summary>This is called when the instance is being disposed.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.Raii.Dispose(System.Boolean)">
            <summary>
            A virtual method that is called at the time of disposal. For this class, the cleanup action provided at the time
            of construction is invoked.
            </summary>
            <param name="disposing">Is true when the object is being disposed, otherwise false.</param>
        </member>
        <member name="T:AllOverIt.Patterns.ResourceInitialization.Raii`1">
            <summary>A strongly-type disposable object implementing the Resource Acquisition Is Initialization idiom.</summary>
            <typeparam name="TType">The type being initialized.</typeparam>
        </member>
        <member name="P:AllOverIt.Patterns.ResourceInitialization.Raii`1.Context">
            <summary>The context provided at the time of initialization.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.Raii`1.#ctor(System.Func{`0},System.Action{`0})">
            <summary>Constructor used to provide the initialization and cleanup actions to be invoked.</summary>
            <param name="initialize">The initialization action to invoke at the time of initialization.</param>
            <param name="cleanUp">The cleanup action to perform when the object is disposed.</param>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.Raii`1.Dispose">
            <summary>Called when the instance is being disposed, resulting in the cleanup action provided at the time of
            construction being invoked.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.Raii`1.Dispose(System.Boolean)">
            <summary>
            A virtual method that is called at the time of disposal. For this class, the cleanup action provided at the time
            of construction is invoked.
            </summary>
            <param name="disposing">Is true when the object is being disposed, otherwise false.</param>
        </member>
        <member name="T:AllOverIt.Patterns.ResourceInitialization.RaiiAsync">
            <summary>An async disposable object implementing the Resource Acquisition Is Initialization idiom.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.RaiiAsync.#ctor(System.Action,System.Func{System.Threading.Tasks.Task})">
            <summary>Constructor used to provide the initialization and cleanup actions to be invoked.</summary>
            <param name="initialize">The initialization action to invoke at the time of initialization.</param>
            <param name="cleanUp">The cleanup action to perform when the object is disposed.</param>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.RaiiAsync.DisposeAsync">
            <summary>Called asynchronously when the instance is being disposed, resulting in the cleanup action
            provided at the time of construction being invoked.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.RaiiAsync.DisposeAsyncCore">
            <summary>Performs the asynchronous disposal of resources.</summary>
        </member>
        <member name="T:AllOverIt.Patterns.ResourceInitialization.RaiiAsync`1">
            <summary>A strongly-type async disposable object implementing the Resource Acquisition Is Initialization idiom.</summary>
            <typeparam name="TType">The type being initialized.</typeparam>
        </member>
        <member name="P:AllOverIt.Patterns.ResourceInitialization.RaiiAsync`1.Context">
            <summary>The context provided at the time of initialization.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.RaiiAsync`1.#ctor(System.Func{`0},System.Func{`0,System.Threading.Tasks.Task})">
            <summary>Constructor used to provide the initialization and cleanup actions to be invoked.</summary>
            <param name="initialize">The initialization action to invoke at the time of initialization.</param>
            <param name="cleanUp">The cleanup action to perform when the object is disposed.</param>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.RaiiAsync`1.DisposeAsync">
            <summary>Called asynchronously when the instance is being disposed, resulting in the cleanup action
            provided at the time of construction being invoked.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ResourceInitialization.RaiiAsync`1.DisposeAsyncCore">
            <summary>Performs the asynchronous disposal of resources.</summary>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.AndLinqSpecification`1">
            <summary>A specification that performs a logical AND operation between two expressions.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.AndLinqSpecification`1.#ctor(AllOverIt.Patterns.Specification.ILinqSpecification{`0},AllOverIt.Patterns.Specification.ILinqSpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.AndLinqSpecification`1.AsExpression">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.AndNotLinqSpecification`1">
            <summary>A specification that performs a logical AND operation between two expressions after negating the result of the right operand.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.AndNotLinqSpecification`1.#ctor(AllOverIt.Patterns.Specification.ILinqSpecification{`0},AllOverIt.Patterns.Specification.ILinqSpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.AndNotLinqSpecification`1.AsExpression">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.AndNotSpecification`1">
            <summary>A specification that performs a logical AND operation between two expressions after negating the result of the right operand.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.AndNotSpecification`1.#ctor(AllOverIt.Patterns.Specification.ISpecification{`0},AllOverIt.Patterns.Specification.ISpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.AndNotSpecification`1.IsSatisfiedBy(`0)">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.AndSpecification`1">
            <summary>A specification that performs a logical AND operation between two expressions.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.AndSpecification`1.#ctor(AllOverIt.Patterns.Specification.ISpecification{`0},AllOverIt.Patterns.Specification.ISpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.AndSpecification`1.IsSatisfiedBy(`0)">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.BinaryLinqSpecification`1">
            <summary>An abstract base class for all concrete LINQ-based binary specifications.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="P:AllOverIt.Patterns.Specification.BinaryLinqSpecification`1.LeftSpecification">
            <summary>The left specification of the binary operation to apply to a candidate.</summary>
        </member>
        <member name="P:AllOverIt.Patterns.Specification.BinaryLinqSpecification`1.RightSpecification">
            <summary>The right specification of the binary operation to apply to a candidate.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.BinaryLinqSpecification`1.#ctor(AllOverIt.Patterns.Specification.ILinqSpecification{`0},AllOverIt.Patterns.Specification.ILinqSpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.BinarySpecification`1">
            <summary>An abstract base class for all concrete binary specifications.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="P:AllOverIt.Patterns.Specification.BinarySpecification`1.LeftSpecification">
            <summary>The left specification of the binary operation to apply to a candidate.</summary>
        </member>
        <member name="P:AllOverIt.Patterns.Specification.BinarySpecification`1.RightSpecification">
            <summary>The right specification of the binary operation to apply to a candidate.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.BinarySpecification`1.#ctor(AllOverIt.Patterns.Specification.ISpecification{`0},AllOverIt.Patterns.Specification.ISpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.ILinqSpecification`1">
            <summary>Defines an interface that allows for complex Expression-based specifications to be built.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.ILinqSpecification`1.AsExpression">
            <summary>Gets an Expression that describes the specification.</summary>
            <returns>An Expression that describes the specification.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.ISpecification`1">
            <summary>Defines an interface that allows for complex specifications to be built.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.ISpecification`1.IsSatisfiedBy(`0)">
            <summary>Applies a specification against a candidate subject.</summary>
            <param name="candidate">The subject to be tested against the specification.</param>
            <returns>True if the candidate satisfies the specification, otherwise false.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.LinqSpecification`1">
            <inheritdoc cref="T:AllOverIt.Patterns.Specification.SpecificationBase`1"/>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.LinqSpecification`1.Create(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>Creates an ad-hoc specification based on the provided predicate.</summary>
            <param name="predicate">The predicate to be used by the specification.</param>
            <returns>An ad-hoc specification based on the provided predicate.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.LinqSpecification`1.AsExpression">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.Specification.LinqSpecification`1.op_Implicit(AllOverIt.Patterns.Specification.LinqSpecification{`0})~System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}}">
            <summary>An implicit operator to return the specification as an Expression&lt;Func&lt;TType, bool&gt;&gt; so it can be used with
            <see cref="T:System.Linq.IQueryable`1"/> based LINQ queries.</summary>
            <param name="specification">The specification to be returned as an Expression&lt;Func&lt;TType, bool&gt;&gt;.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.LinqSpecification`1.op_Explicit(AllOverIt.Patterns.Specification.LinqSpecification{`0})~System.Func{`0,System.Boolean}">
            <summary>An explicit operator to return the specification as a Func&lt;TType, bool&gt; so it can be used with
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> based LINQ queries.</summary>
            <param name="specification">The specification to be returned as a Func&lt;TType, bool&gt;.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.LinqSpecification`1.op_BitwiseAnd(AllOverIt.Patterns.Specification.LinqSpecification{`0},AllOverIt.Patterns.Specification.LinqSpecification{`0})">
            <summary>Provides support for operator &amp;&amp;.</summary>
            <param name="leftSpecification">The left operand applied to the operator.</param>
            <param name="rightSpecification">The right operand applied to the operator.</param>
            <returns>A new specification that AND's the provided specifications.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.LinqSpecification`1.op_BitwiseOr(AllOverIt.Patterns.Specification.LinqSpecification{`0},AllOverIt.Patterns.Specification.LinqSpecification{`0})">
            <summary>Provides support for operator ||.</summary>
            <param name="leftSpecification">The left operand applied to the operator.</param>
            <param name="rightSpecification">The right operand applied to the operator.</param>
            <returns>A new specification that OR's the provided specifications.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.LinqSpecification`1.op_LogicalNot(AllOverIt.Patterns.Specification.LinqSpecification{`0})">
            <summary>Provides support for operator ! (Not).</summary>
            <param name="specification">The operand applied to the operator.</param>
            <returns>A new specification that inverts the result of the provided specification.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.LinqSpecification`1.IsSatisfiedBy(`0)">
            <inheritdoc cref="T:AllOverIt.Patterns.Specification.SpecificationBase`1"/>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.NotLinqSpecification`1">
            <summary>A specification that performs a logical NOT operation on a provided expression.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.NotLinqSpecification`1.#ctor(AllOverIt.Patterns.Specification.ILinqSpecification{`0})">
            <summary>Constructor.</summary>
            <param name="specification">The specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.NotLinqSpecification`1.AsExpression">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.NotSpecification`1">
            <summary>A specification that performs a logical NOT operation on a provided expression.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.NotSpecification`1.#ctor(AllOverIt.Patterns.Specification.ISpecification{`0})">
            <summary>Constructor.</summary>
            <param name="specification">The specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.NotSpecification`1.IsSatisfiedBy(`0)">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.OrLinqSpecification`1">
            <summary>A specification that performs a logical OR operation between two expressions.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.OrLinqSpecification`1.#ctor(AllOverIt.Patterns.Specification.ILinqSpecification{`0},AllOverIt.Patterns.Specification.ILinqSpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.OrLinqSpecification`1.AsExpression">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.OrNotLinqSpecification`1">
            <summary>A specification that performs a logical OR operation between two expressions after negating the result of the right operand.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.OrNotLinqSpecification`1.#ctor(AllOverIt.Patterns.Specification.ILinqSpecification{`0},AllOverIt.Patterns.Specification.ILinqSpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.OrNotLinqSpecification`1.AsExpression">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.OrNotSpecification`1">
            <summary>A specification that performs a logical OR operation between two expressions after negating the result of the right operand.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.OrNotSpecification`1.#ctor(AllOverIt.Patterns.Specification.ISpecification{`0},AllOverIt.Patterns.Specification.ISpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.OrNotSpecification`1.IsSatisfiedBy(`0)">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.OrSpecification`1">
            <summary>A specification that performs a logical OR operation between two expressions.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.OrSpecification`1.#ctor(AllOverIt.Patterns.Specification.ISpecification{`0},AllOverIt.Patterns.Specification.ISpecification{`0})">
            <summary>Constructor.</summary>
            <param name="leftSpecification">The left specification applied against a candidate.</param>
            <param name="rightSpecification">The right specification applied against a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.OrSpecification`1.IsSatisfiedBy(`0)">
            <inheritdoc />
        </member>
        <member name="T:AllOverIt.Patterns.Specification.Specification`1">
            <inheritdoc cref="T:AllOverIt.Patterns.Specification.SpecificationBase`1"/>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.Specification`1.Create(System.Func{`0,System.Boolean})">
            <summary>Creates an ad-hoc specification based on the provided predicate.</summary>
            <param name="predicate">The predicate to be used by the specification.</param>
            <returns>An ad-hoc specification based on the provided predicate.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.Specification`1.op_BitwiseAnd(AllOverIt.Patterns.Specification.Specification{`0},AllOverIt.Patterns.Specification.Specification{`0})">
            <summary>Provides support for operator &amp;&amp;.</summary>
            <param name="leftSpecification">The left operand applied to the operator.</param>
            <param name="rightSpecification">The right operand applied to the operator.</param>
            <returns>A new specification that performs a logical AND operation between two expressions.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.Specification`1.op_BitwiseOr(AllOverIt.Patterns.Specification.Specification{`0},AllOverIt.Patterns.Specification.Specification{`0})">
            <summary>Provides support for operator ||.</summary>
            <param name="leftSpecification">The left operand applied to the operator.</param>
            <param name="rightSpecification">The right operand applied to the operator.</param>
            <returns>A new specification that performs a logical OR operation between two expressions.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.Specification`1.op_LogicalNot(AllOverIt.Patterns.Specification.Specification{`0})">
            <summary>Provides support for operator ! (Not).</summary>
            <param name="specification">The operand applied to the operator.</param>
            <returns>A new specification that that performs a logical NOT operation between two expressions.</returns>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.SpecificationBase`1">
            <summary>An abstract base class for all concrete specifications.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.SpecificationBase`1.IsSatisfiedBy(`0)">
            <summary>Implemented by concrete classes to perform the required specification test.</summary>
            <param name="candidate">The subject to be tested against the specification.</param>
            <returns>True if the candidate satisfies the specification, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.SpecificationBase`1.op_True(AllOverIt.Patterns.Specification.SpecificationBase{`0})">
            <summary>Required in combination with operator &amp; and | to support operator &amp;&amp; and ||.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.SpecificationBase`1.op_False(AllOverIt.Patterns.Specification.SpecificationBase{`0})">
            <summary>Required in combination with operator &amp; and | to support operator &amp;&amp; and ||.</summary>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.UnaryLinqSpecification`1">
            <summary>An abstract base class for all concrete LINQ-based unary specifications.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="P:AllOverIt.Patterns.Specification.UnaryLinqSpecification`1.Specification">
            <summary>The specification of the unary operation to apply to a candidate.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.UnaryLinqSpecification`1.#ctor(AllOverIt.Patterns.Specification.ILinqSpecification{`0})">
            <summary>Constructor.</summary>
            <param name="specification">The unary specification to apply to a candidate.</param>
        </member>
        <member name="T:AllOverIt.Patterns.Specification.UnarySpecification`1">
            <summary>An abstract base class for all concrete unary specifications.</summary>
            <typeparam name="TType">The candidate type the specification applies to.</typeparam>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.UnarySpecification`1.#ctor(AllOverIt.Patterns.Specification.ISpecification{`0})">
            <summary>Constructor.</summary>
            <param name="specification">The unary specification to apply to a candidate.</param>
        </member>
        <member name="M:AllOverIt.Patterns.Specification.UnarySpecification`1.IsSatisfiedBy(`0)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.Equals(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.CompareTo(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.op_Equality(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1},AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the ValueObject instances are equal, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.op_Inequality(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1},AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the ValueObject instances are not equal, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.op_GreaterThan(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1},AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the left operand is greater than the right operand, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.op_GreaterThanOrEqual(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1},AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the left operand is greater than or equal to the right operand, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.op_LessThan(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1},AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the left operand is less than the right operand, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.op_LessThanOrEqual(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1},AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})">
            <param name="left">The left operand of the comparison.</param>
            <param name="right">The right operand of the comparison.</param>
            <returns>True if the left operand is less than or equal to the right operand, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.op_Implicit(AllOverIt.Patterns.ValueObject.ValueObject{`0,`1})~`0">
            <summary>Implicit operator to convert a ValueObject to its underlying value equivalent.</summary>
            <param name="value">The value to implicitly convert.</param>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.op_Explicit(`0)~AllOverIt.Patterns.ValueObject.ValueObject{`0,`1}">
            <summary>Explicit operator to convert an underlying type to its ValueObject equivalent.</summary>
            <param name="value">The value to explicitly convert.</param>
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Patterns.ValueObject.ValueObject`2.ValidateValue(`0)">
            <summary>Override to validate the initialized value.</summary>
            <param name="value">The value to be validated.</param>
        </member>
        <member name="T:AllOverIt.Process.Process">
            <summary>Provides support for general process activities.</summary>
        </member>
        <member name="M:AllOverIt.Process.Process.ExecuteAndWaitAsync(System.String,System.String,System.String,System.TimeSpan)">
            <summary>Executes a process and captures the standard output and standard error streams.</summary>
            <param name="workingDirectory">The working directory to be used by the process to be executed</param>
            <param name="processFilename">The name of the executable to be spawned.</param>
            <param name="arguments">Arguments to be passed to the new process.</param>
            <param name="timeout">The period to wait for the process to exit before timing out.</param>
            <returns>The exit code, standard and error output of the executed process.</returns>
        </member>
        <member name="M:AllOverIt.Process.Process.ExecuteAndWaitAsync(System.String,System.String,System.String,System.Int32)">
            <summary>Executes a process and captures the standard output and standard error streams.</summary>
            <param name="workingDirectory">The working directory to be used by the process to be executed</param>
            <param name="processFilename">The name of the executable to be spawned.</param>
            <param name="arguments">Arguments to be passed to the new process.</param>
            <param name="timeoutMilliseconds">The number of milliseconds to wait for the process to exit before timing out. Pass
            a value of -1 to wait indefinitely.</param>
            <returns>The exit code, standard and error output of the executed process.</returns>
        </member>
        <member name="T:AllOverIt.Process.ProcessOutput">
            <summary>Contains the output and exit status of a process executed via the <c>Process.ExecuteAndWaitAsync</c> method.</summary>
        </member>
        <member name="P:AllOverIt.Process.ProcessOutput.ExitCode">
            <summary>The exit code of the process.</summary>
        </member>
        <member name="P:AllOverIt.Process.ProcessOutput.StandardOutput">
            <summary>The output captured from the standard output stream.</summary>
        </member>
        <member name="P:AllOverIt.Process.ProcessOutput.StandardError">
            <summary>The output captured from the standard error stream.</summary>
        </member>
        <member name="M:AllOverIt.Process.ProcessOutput.#ctor(System.Int32,System.String,System.String)">
            <summary>Initializes a new <c>ProcessOutput</c> instance.</summary>
            <param name="exitCode">The exit code of the process.</param>
            <param name="standardOutput">The output captured from the standard output stream.</param>
            <param name="standardError">The output captured from the standard error stream.</param>
        </member>
        <member name="T:AllOverIt.Reflection.BindingOptions">
            <Summary>Specifies binding options that, when combined, provide the ability to filter reflection operations that
            target property and method information on a type.</Summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Static">
            <summary>
            Filter reflection operations to <i>static</i> scope.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Instance">
            <summary>
            Filter reflection operations to <i>instance</i> (non-static) scope.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Abstract">
            <summary>
            Filter reflection operations to <i>abstract</i> access.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Virtual">
            <summary>
            Filter reflection operations to <i>virtual</i> access.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.NonVirtual">
            <summary>
            Filter reflection operations to a <i>non-virtual</i> access.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Internal">
            <summary>
            Filter reflection operations to <i>internal</i> visibility.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Private">
            <summary>
            Filter reflection operations to <i>private</i> visibility.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Protected">
            <summary>
            Filter reflection operations to <i>protected</i> visibility.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Public">
            <summary>
            Filter reflection operations to <i>public</i> visibility.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.DefaultScope">
            <summary>
            Filter reflection operations to <i>static</i> or <i>instance</i> scope.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.DefaultAccessor">
            <summary>
            Filter reflection operations to <i>abstract</i>, <i>virtual</i>, or <i>non-virtual</i> access.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.DefaultVisibility">
            <summary>
            Filter reflection operations to <i>public</i> or <i>protected</i> access.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.Default">
            <summary>
            Filter reflection operations to use <see cref="F:AllOverIt.Reflection.BindingOptions.DefaultScope"/> scope, <see cref="F:AllOverIt.Reflection.BindingOptions.DefaultAccessor"/> access,
            and <see cref="F:AllOverIt.Reflection.BindingOptions.DefaultVisibility"/> visibility.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.AllScope">
            <summary>
            Filter reflection operations to <i>static</i> or <i>instance</i> scope.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.AllAccessor">
            <summary>
            Filter reflection operations to <i>abstract</i>, <i>virtual</i>, or <i>non-virtual</i> access.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.AllVisibility">
            <summary>
            Filter reflection operations to <i>public</i>, <i>protected</i>, <i>private</i>, or <i>internal</i> access.
            </summary>
        </member>
        <member name="F:AllOverIt.Reflection.BindingOptions.All">
            <summary>
            Filter reflection operations to use <see cref="F:AllOverIt.Reflection.BindingOptions.AllScope"/> scope, <see cref="F:AllOverIt.Reflection.BindingOptions.AllAccessor"/> access,
            and <see cref="F:AllOverIt.Reflection.BindingOptions.AllVisibility"/> visibility.
            </summary>
        </member>
        <member name="T:AllOverIt.Reflection.ReflectionHelper">
            <summary>Contains a number of helper functions related to reflection.</summary>
        </member>
        <member name="M:AllOverIt.Reflection.ReflectionHelper.GetPropertyInfo``1(System.String)">
            <summary>Gets the <see cref="T:System.Reflection.PropertyInfo"/> (property metadata) for a given property on a <typeparamref name="TType"/>.</summary>
            <typeparam name="TType">The type to obtain the property metadata from.</typeparam>
            <param name="propertyName">The name of the property to obtain metadata for.</param>
            <returns>The property metadata, as <see cref="T:System.Reflection.PropertyInfo"/>, of a specified property on the specified <typeparamref name="TType"/>.</returns>
            <remarks>When class inheritance is involved, this method returns the first property found, starting at the type represented
            by <typeparamref name="TType"/>.</remarks>
        </member>
        <member name="M:AllOverIt.Reflection.ReflectionHelper.GetPropertyInfo``1(AllOverIt.Reflection.BindingOptions,System.Boolean)">
            <summary>Gets <see cref="T:System.Reflection.PropertyInfo"/> (property metadata) for a given <typeparamref name="TType"/> and binding option.</summary>
            <typeparam name="TType">The type to obtain property metadata for.</typeparam>
            <param name="binding">The binding option that determines the scope, access, and visibility rules to apply when searching for the metadata.</param>
            <param name="declaredOnly">If true, the metadata of properties in the declared class as well as base class(es) are returned.
            If false, only property metadata of the declared type is returned.</param>
            <returns>The property metadata, as <see cref="T:System.Reflection.PropertyInfo"/>, of a specified <typeparamref name="TType"/>.</returns>
            <remarks>When class inheritance is involved, this method returns the first property found, starting at the type represented
            by <typeparamref name="TType"/>.</remarks>
        </member>
        <member name="M:AllOverIt.Reflection.ReflectionHelper.GetMethodInfo``1(AllOverIt.Reflection.BindingOptions,System.Boolean)">
            <summary>Gets <see cref="T:System.Reflection.MethodInfo"/> (method metadata) for a given <typeparamref name="TType"/> and binding option.</summary>
            <typeparam name="TType">The type to obtain method metadata for.</typeparam>
            <param name="binding">The binding option that determines the scope, access, and visibility rules to apply when searching for the metadata.</param>
            <param name="declaredOnly">If true, the metadata of properties in the declared class as well as base class(es) are returned.
            If false, only method metadata of the declared type is returned.</param>
            <returns>The method metadata, as <see cref="T:System.Reflection.MethodInfo"/>, of a specified <typeparamref name="TType"/>.</returns>
            <remarks>When class inheritance is involved, this method returns the first method found, starting at the type represented
            by <typeparamref name="TType"/>.</remarks>
        </member>
        <member name="M:AllOverIt.Reflection.ReflectionHelper.GetMethodInfo``1(System.String)">
            <summary>Gets <see cref="T:System.Reflection.MethodInfo"/> (method metadata) for a given <typeparamref name="TType"/> method with a given name and no arguments.</summary>
            <typeparam name="TType">The type to obtain method metadata for.</typeparam>
            <param name="name">The name of the method.</param>
            <returns>The method metadata, as <see cref="T:System.Reflection.MethodInfo"/>, of a specified <typeparamref name="TType"/> with a given name and no arguments.</returns>
            <remarks>All instance, static, public, and non-public methods are searched.</remarks>
        </member>
        <member name="M:AllOverIt.Reflection.ReflectionHelper.GetMethodInfo``1(System.String,System.Type[])">
            <summary>Gets <see cref="T:System.Reflection.MethodInfo"/> (method metadata) for a given <typeparamref name="TType"/> method with a given name and argument types.</summary>
            <typeparam name="TType">The type to obtain method metadata for.</typeparam>
            <param name="name">The name of the method.</param>
            <param name="types">The argument types expected on the method</param>
            <returns>The method metadata, as <see cref="T:System.Reflection.MethodInfo"/>, of a specified <typeparamref name="TType"/> with a given name and argument types.</returns>
            <remarks>All instance, static, public, and non-public methods are searched.</remarks>
        </member>
        <member name="M:AllOverIt.Reflection.ReflectionHelper.SetMemberValue(System.Reflection.MemberInfo,System.Object,System.Object)">
            <summary>Sets the value of a target property or field using its associated <see cref="T:System.Reflection.MemberInfo"/>.</summary>
            <param name="memberInfo">The <see cref="T:System.Reflection.MemberInfo"/> of the property or field to have its value set.</param>
            <param name="target">The target object being updated.</param>
            <param name="value">The value to assign to the property or field.</param>
        </member>
        <member name="M:AllOverIt.Reflection.ReflectionHelper.GetMemberValue(System.Reflection.MemberInfo,System.Object)">
            <summary>Gets the value of a target property or field using its associated <see cref="T:System.Reflection.MemberInfo"/>.</summary>
            <param name="memberInfo">The <see cref="T:System.Reflection.MemberInfo"/> of the property or field being read.</param>
            <param name="target">The target object being read.</param>
            <returns>The value of the property or field referred to by <paramref name="memberInfo" />.</returns>
        </member>
        <member name="M:AllOverIt.Reflection.ReflectionHelper.GetMemberType(System.Reflection.MemberInfo)">
            <summary>Gets the property, field or method call return type associated with the <paramref name="memberInfo"/>.</summary>
            <param name="memberInfo">The <see cref="T:System.Reflection.MemberInfo"/> of the property, field or method call.</param>
            <returns>The property, field or method call return type.</returns>
        </member>
        <member name="T:AllOverIt.Threading.IReadWriteLock">
            <summary>Represents a lock that is used to manage access to a resource, allowing multiple threads
            for reading or exclusive access for writing.</summary>
        </member>
        <member name="M:AllOverIt.Threading.IReadWriteLock.EnterReadLock(System.Boolean)">
            <summary>Blocks the calling thread until a read lock is acquired. The lock will be acquired immediately
            if there are no current write locks.</summary>
            <param name="upgradeable">Indicates if the read lock can be upgraded to a write lock.</param>
        </member>
        <member name="M:AllOverIt.Threading.IReadWriteLock.TryEnterReadLock(System.Boolean,System.Int32)">
            <summary>Blocks the calling thread while trying to acquire a read lock within the specified timeout period.</summary>
            <param name="upgradeable">Indicates if the read lock can be upgraded to a write lock.</param>
            <param name="millisecondsTimeout">The timeout period to block the calling thread while trying to acquire the read lock.
            A value of 0 indicates the method should return if the lock cannot be immediately acquired.
            A value of -1 will result in the calling thread being blocked indefinitely, until the lock is acquired.</param>
            <returns>True if the lock was acquired, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Threading.IReadWriteLock.ExitReadLock">
            <summary>Exists a previously acquired read lock.</summary>
        </member>
        <member name="M:AllOverIt.Threading.IReadWriteLock.EnterWriteLock">
            <summary>Blocks the calling thread until a write lock is acquired.</summary>
        </member>
        <member name="M:AllOverIt.Threading.IReadWriteLock.TryEnterWriteLock(System.Int32)">
            <summary>Blocks the calling thread while trying to acquire a write lock within the specified timeout period.</summary>
            <param name="millisecondsTimeout">The timeout period to block the calling thread while trying to acquire the write lock.
            A value of 0 indicates the method should return if the lock cannot be immediately acquired.
            A value of -1 will result in the calling thread being blocked indefinitely, until the lock is acquired.</param>
            <returns>True if the lock was acquired, otherwise false.</returns>
        </member>
        <member name="M:AllOverIt.Threading.IReadWriteLock.ExitWriteLock">
            <summary>Exists a previously acquired write lock.</summary>
        </member>
        <member name="T:AllOverIt.Threading.NoLock">
            <summary>Implements a read/write lock that performs no locking actions (null object pattern).</summary>
            <remarks>Use this class where a non-blocking locking policy is required for use within a single thread.</remarks>
        </member>
        <member name="M:AllOverIt.Threading.NoLock.EnterReadLock(System.Boolean)">
            <summary>Performs no action.</summary>
            <param name="upgradeable">Ignored.</param>
        </member>
        <member name="M:AllOverIt.Threading.NoLock.TryEnterReadLock(System.Boolean,System.Int32)">
            <summary>Performs no action.</summary>
            <param name="upgradeable">Ignored.</param>
            <param name="millisecondsTimeout">Ignored.</param>
            <returns>Always returns true.</returns>
        </member>
        <member name="M:AllOverIt.Threading.NoLock.ExitReadLock">
            <summary>Performs no action.</summary>
        </member>
        <member name="M:AllOverIt.Threading.NoLock.EnterWriteLock">
            <summary>Performs no action.</summary>
        </member>
        <member name="M:AllOverIt.Threading.NoLock.TryEnterWriteLock(System.Int32)">
            <summary>Performs no action.</summary>
            <param name="millisecondsTimeout">Ignored.</param>
        </member>
        <member name="M:AllOverIt.Threading.NoLock.ExitWriteLock">
            <summary>Performs no action.</summary>
        </member>
        <member name="M:AllOverIt.Threading.NoLock.Dispose">
            <summary>Performs no action.</summary>
        </member>
        <member name="T:AllOverIt.Threading.ReadWriteLock">
            <summary>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or
            exclusive access for writing.</summary>
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.#ctor">
            <summary>Constructor.</summary>
            <remarks>Defaults to a non-recursive lock policy.</remarks>
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.#ctor(System.Threading.LockRecursionPolicy)">
            <summary>Constructor.</summary>
            <param name="recursionPolicy">Determines if a lock can be entered multiple times by the same thread.</param>
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.EnterReadLock(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.TryEnterReadLock(System.Boolean,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.ExitReadLock">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.EnterWriteLock">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.TryEnterWriteLock(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.ExitWriteLock">
            <inheritdoc />
        </member>
        <member name="M:AllOverIt.Threading.ReadWriteLock.Dispose">
            <summary>Disposes of the internal lock.</summary>
        </member>
    </members>
</doc>
